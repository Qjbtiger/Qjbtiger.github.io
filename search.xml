<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1月18号创新班总结</title>
    <url>/Informatics%20In%20Junior/1%E6%9C%8818%E5%8F%B7%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天是1月18号，也是放寒假的第一天。虽然有些不情愿，但是，学习信息学的热情是阻挡不了我的。</p>
<p>今天早上学习的呢，主要试一下几个方面：</p>
<h2 id="一、选择插入排序"><a href="#一、选择插入排序" class="headerlink" title="一、选择插入排序"></a>一、选择插入排序</h2><pre><code>选择插入排序的思想主要是：有N个数，a1，a2..ai-1,ai,ai+1..an,那么，我们可以看成两个区域，一个是有序的，一个是无序的，[]&lt;a1，a2..ai-1,ai,ai+1..an&gt;([]是有序的，&lt;&gt;是无序的)，那么，假设数列变成[a1，a2..ai-1],&lt;ai,ai+2..an&gt;,那么，要想让ai从无序区道有序区，需要在有序区找一个空位，那么，我们需要扫描一遍，当ap&lt;ai&lt;aq或ap&gt;ai&gt;aq时，ap,aq为所扫描空位的两边的数据,那么数据向后移一位，ai就从无序区到了有序区，如此类推……

源程序（借用老师）</code></pre><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];<span class="comment">//读入</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j,tmp;</span><br><span class="line">        tmp= a[i];<span class="comment">//tem暂存ai值，因为在后面数据要后移</span></span><br><span class="line">        <span class="keyword">for</span> (j=i; j!=<span class="number">0</span> &amp;&amp; a[j<span class="number">-1</span>]&lt;tmp ; j--)<span class="comment">//1.j!=0当j等于0是应退出，否则越界；2.a[j-1]&lt;tmp从大到小，只要小于ai就继续</span></span><br><span class="line">        a[j]=a[j<span class="number">-1</span>];<span class="comment">//后移</span></span><br><span class="line">        a[j] = tmp;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i]&lt;&lt;<span class="string">"   "</span>;<span class="comment">//输出</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二、函数与过程（子函数）"><a href="#二、函数与过程（子函数）" class="headerlink" title="二、函数与过程（子函数）"></a>二、函数与过程（子函数）</h2><p>简单地说，子程序的格式是：类型 函数名 （类型+参数……）；</p>
<p>当类型是int或double等非空类型的子程序就是函数，是可以返回一个数值的；二若是空类型时（void）是，并不返回，所以这就是过程。</p>
<p>其实，调用函数与过程，基本结构与pascal是一样的，但是，子程序定义头的格式有些不同。</p>
<p>PS：在c++里，子程序可以定义在主程序下方，而且，我们也习惯这么做，因为，我们西归先看主程序，看到有子程序名才会向下看，而不会马上就看子程序。</p>
<p>具体如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">类型 函数名 （类型+参数……）；</span><br><span class="line">&#123;</span><br><span class="line"> 语句；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">如：(<span class="number">1</span>)函数</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"> ……</span><br><span class="line"></span><br><span class="line"> <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ……</span><br><span class="line"> ans=fac(n);</span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="number">2</span>)过程</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">try</span><span class="params">(<span class="keyword">int</span> x,y)</span></span>;</span><br><span class="line">&#123;</span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ……</span><br><span class="line"> <span class="keyword">try</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"> ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、递归"><a href="#三、递归" class="headerlink" title="三、递归"></a>三、递归</h2><p>学习了子程序，我们知道了在主程序调用子程序，可以使程序实现模块化，但是，如果是在子程序里调用自己本身呢？</p>
<p>那么，这一种情况就叫做递归。我们可以用一道题来解释和应用。</p>
<p>我们知道，n！是指n的阶乘，既n!=1<em>2</em>3<em>4</em>…*n，那么，我们知道n，求n！</p>
<p>那么我们知道， n!=1<em>2</em>3<em>4</em>…<em>n，换句话说，n!= 1</em>2<em>3</em>4<em>…</em>n-1<em>n=(1</em>2<em>3</em>4<em>…</em>n-1)<em>n=(n-1)!</em>n。现在我们很直观的看到，n!= (n-1)!*n。我们以5！为例，</p>
<p>∵5！=5<em>4！，4！=4</em>3！，3！=3<em>2！，2！=2</em>1！，1！=1</p>
<p>∴2！=2<em>1！=2</em>1=2,3！=3<em>2！=3</em>2=6,4！=4<em>3！=4</em>6=24，5！=5<em>4！=5</em>24=120</p>
<p>∴5！=120</p>
<p>这样实现起来非常简单，源程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;fac(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//边界，1!=1</span></span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    tmp=k*fac(k<span class="number">-1</span>);<span class="comment">//n!=(n-1)!*n</span></span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、求下一个全排列"><a href="#四、求下一个全排列" class="headerlink" title="四、求下一个全排列"></a>四、求下一个全排列</h2><p>下一个全排列，也就是说，一个数列，如何移动，是使这个数列比它大但又和她的差最小。</p>
<p>比如说，（8,9,5,7,6,4,3,2,1,0），我们发现，只要将6放入5的位置，然后之后的数字从小到大排列，既（8,9,6,1,2,3,4,5,7）。因此，我们可以认为，只要扫描，从小到大数列后的第一个数字，在后面找到比它大但又差最小的数字放入这个数字的位置，然后包括原来的数字在内的后面数字从小到大排列，即可。</p>
<h2 id="五、排队等水"><a href="#五、排队等水" class="headerlink" title="五、排队等水"></a>五、排队等水</h2><p>有n个人打水，每个人有一定打水时间，问怎样排队使总等待时间最短。</p>
<p>我们知道，知道让等待时间从小到大排即可，但为什么呢？我们可以选择其中两个人，ap和aq，ap的等待时间小于aq的等待时间，若ap和aq调换，发现这并不是最优解，所以让等待时间从小到大排为最优解。</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>1月18号创新班总结2</title>
    <url>/Informatics%20In%20Junior/1%E6%9C%8818%E5%8F%B7%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%932/</url>
    <content><![CDATA[<p>1月24号的课程，我请假了半天，但是没有关系，因为老师为我们留下了视频，我们可以看视频回顾，即可以复习又可以留念，一举两得。而且，我还需要加倍地学习，我不能辜负老师对我们的期望。下面是今天学习的几个知识：</p>
<h2 id="一：关于全排列的几个问题"><a href="#一：关于全排列的几个问题" class="headerlink" title="一：关于全排列的几个问题"></a>一：关于全排列的几个问题</h2><p>还是那一个问题，求下一个全排列。</p>
<p>我们从两个例子可以发现，我们要的到下一个全排列，我们要做到以下几个步骤：</p>
<ol>
<li><p>从左向右扫描，找到一个向上的序列，因为我们所需的那一个数列是要比他大的，若是从大到小，只要大的和小的交换即可，所以不妥。这样就可以找到需要改变的哪一个数位。如1，{5,4}就是我们找到的向上的数列；</p>
</li>
<li><p>找到这一个上升的数列突然下降的哪一个数，与哪一个向上的数列的最右端的那一个数进行交换，然后整一个数列（由于数字交换了，也许不是上升的了）进行排序即可。如1，{5,4}的突然下降的数字是3，而数列的右端是4，交换，数列排序，变成{2,1,4,3,5}。</p>
</li>
</ol>
<p>源程序如下（借用老师）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1001</span>],n;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">find_p</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">find_q</span><span class="params">( <span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span><span class="comment">//要习惯在主程序前先写子程序名</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    <span class="comment">// work();</span></span><br><span class="line">    <span class="comment">// write();</span></span><br><span class="line">    next_permutation(a+<span class="number">0</span>, a+n);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p=find_p();<span class="comment">//找到向上的数列后突然向下的那一个数</span></span><br><span class="line">    <span class="keyword">int</span> q=find_q(a[p]);<span class="comment">//找到与p进行交换的数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//cout &lt;&lt;p &lt;&lt;" "&lt;&lt;q&lt;&lt;endl;//这是用来调试的办法，我们可以尝试这样输出来在c++调试</span></span><br><span class="line"></span><br><span class="line">    swap(a[p],a[q]);</span><br><span class="line">    <span class="keyword">for</span> (p++,q=n<span class="number">-1</span>; p&lt;q ; ++p, --q)</span><br><span class="line">        swap(a[p],a[q]);<span class="comment">//进行交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">find_p</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i&gt;<span class="number">0</span> &amp;&amp; a[i]&lt;a[i<span class="number">-1</span>] ; i--);</span><br><span class="line">        <span class="keyword">if</span> (i==<span class="number">0</span>) &#123; <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERROR!"</span>; <span class="built_in">exit</span>(<span class="number">0</span>); &#125;</span><br><span class="line">    <span class="keyword">return</span> i<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">find_q</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (;  a[i]&lt;x ; i--);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i) <span class="built_in">cin</span>&gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一个问题，给定一个全排列求第几个。</p>
<p>该怎么办呢？比如说{2，4，3，1}，一个个数下来，是第11个。但是，如果是更大的数，就不可以一个个数了，那该怎么办呢?</p>
<p>我们知道，全排列为n的数目一共有n！个。比如4，就有4！=24个。那么，开头为1的数列有6=（4-1）！=3！，2有6个，3有6个，4也有6个。而且，开头为1，第二位为1有2=（4-2）！=2！，2有2个，3有2个，4也有2个。</p>
<p>因此，对于一个全排列n，我们可以确定第一位的数字，然后ans+=(n-i)!*k，ans是累加答案，i是第几位，k是指数字的前几位，我们可以用布尔数组f来储存什么数字有什么数字没有，再看看a[i]这个数字在f中非真的排列位置，即为k。</p>
<h2 id="二：浅谈分治"><a href="#二：浅谈分治" class="headerlink" title="二：浅谈分治"></a>二：浅谈分治</h2><p>简单来说，就是要解决一个大问题，我们可以把这几个问题分解成几个小问题，按如此规律解决，最终解决大问题。</p>
<p>比如说快排，就是分治法。</p>
<p>快排的思想，就是说：有那么一个数列去中间数mid，然后使min左边的数都小于min，右边的数都大于min，然后，我们再将{1-min}{min+1-n}这么做即可。那么，我们可以发现左边的数都小于右边的数，也就排好了序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//#include &lt;alrigothm&gt;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1000000</span>],n,x,y;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qqsort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    qqsort(<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i) <span class="built_in">cin</span>&gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qqsort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid=a[(l+r)/<span class="number">2</span>];<span class="comment">//找中间点mid</span></span><br><span class="line">    <span class="keyword">int</span> i=l,j=r;</span><br><span class="line">    <span class="keyword">for</span> ( ;i&lt;=j;i++,j--)<span class="comment">//每次i加1，j减1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ;a[i]&lt;mid;i++);<span class="comment">//找到比他小的</span></span><br><span class="line">      </span><br><span class="line">        <span class="keyword">for</span> ( ;a[j]&gt;mid;j--);<span class="comment">//找到比他大的的</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i&lt;=j) swap(a[i],a[j]);<span class="comment">//交换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    qqsort(l,j); qqsort(i,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三：自顶向下编程工程"><a href="#三：自顶向下编程工程" class="headerlink" title="三：自顶向下编程工程"></a>三：自顶向下编程工程</h2><p>自顶向下就是指先写结构再写细节。比如说，我们编程时，压板都是先写子程序的名称再写主程序的内容，在主程序里调用子程序写名，最后编写子程序。主程序是结构，子程序是细节。所以这就是自顶向下的编程工程方法。</p>
<h2 id="四：学习方法"><a href="#四：学习方法" class="headerlink" title="四：学习方法"></a>四：学习方法</h2><p>老师向我们讲了一个学生的例子，他尽管不怎么喜欢做作业，但是，他认为作业太简单了。其次，他还有一个习惯，就是他很喜欢做笔记，记录在信息学的点点滴滴。因此，也就造就了这一个“世界第一”。因此，我要向他好好学习。</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo Useful Commands</title>
    <url>/Hexo/Hexo-Useful-Commands/</url>
    <content><![CDATA[<p>Record some useful commands for maintaining Hexo website.</p>
<a id="more"></a>

<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>Supposing you have install <strong>Git</strong> and <strong>Nodejs</strong>.</p>
<p>Install:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>

<h2 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h2><h3 id="Create-a-new-article"><a href="#Create-a-new-article" class="headerlink" title="Create a new article"></a>Create a new article</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new <span class="string">"Hello"</span> <span class="comment"># simplest example</span></span><br></pre></td></tr></table></figure>

<h2 id="Generate-amp-Publish"><a href="#Generate-amp-Publish" class="headerlink" title="Generate &amp; Publish"></a>Generate &amp; Publish</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo generate <span class="comment"># generate static files</span></span><br><span class="line">hexo deploy <span class="comment"># deploy to github or other code repository</span></span><br><span class="line">hexo g -d <span class="comment"># take both actions</span></span><br><span class="line">hexo d -g <span class="comment"># same as above</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>5.25创新班总结</title>
    <url>/Informatics%20In%20Junior/5.25%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们主要是认识了一种新的数据结构，堆。</p>
<p>定义：堆，顾名思义，就是把东西堆在一起，类似于一座金字塔。其实，堆也是一棵树，不过是一颗完全二叉树。也就是说，对于一个根节点来说，它只有三种状态：①没有孩子②只有左孩子③即有左孩子，又有右孩子。并不存在，只有右孩子的状态存在。</p>
<p>性质：对于一个堆来说，由于它是一个完全二叉树，因此，我们自上而下把它进行编号，如图：</p>
<p>他不见了。</p>
<p>那么，对于一个根节点的编号k来说，它的左孩子为k<em>2，右孩子为k</em>2+1，而它的父节点就是[k/2]。这也是完全二叉树的性质。</p>
<p>建堆：对于一个堆，由于我们知道了上述性质，所以，我们就可以用一个数组来储存这一个堆。我们可以将平常那样正常读入，通过[k<em>2]、[k</em>2+1]和[k/2]来找到左孩子、右孩子和根节点。</p>
<p>建最小堆（或最大堆）：首先我们要明确一点，那就是，对于一个堆来说，根节点总比它的左孩子，右孩子小（大）。 </p>
<p>他不见了。</p>
<p>那么，这一点我们可以在读入完成。</p>
<p>① 我们每读入一个数时，无论大小，先把它放在堆末（即数组的最后面）。</p>
<p>② 我们跟它的父节点[k/2]进行比较，如果这个数比它的父节点小（大），则父节点，与当前节点交换。</p>
<p>③ 这样，我们就把问题变成了它的根节点。</p>
<p>④ 只要当前节点大于（小于）父节点，或者当前节点就是堆顶，那么，任务完成。</p>
<p>维护最小堆（最大堆）：如果我把堆顶的那个数据拿走，但我们还要维护好最小堆（最大堆），那怎么办呢？</p>
<p>① 我们那就把堆末的那个数据提上来，补掉那个窟窿。现在，我们的任务是达这个补上来的数据安排到合适的位置了。</p>
<p>② 首先，我们先盘判断它的左右孩子，选择数据更小的那个孩子。因为如果选择数据更大的，那么结果就不是最优了。因为，把大的孩子那个交换上来后，必然会大于小的那个孩子，结果不优了。</p>
<p>③ 那么，我们交换根节点和选择的那个孩子的数据。</p>
<p>④ 现在，我们的任务就变成对那个选择的孩子再次进行上述步骤了。如果这个节点小于它的左右孩子，或没有孩子了，任务完成。</p>
<p>堆排序：对于一个最小堆（最大堆），我们发现堆顶的就是最小的（最大的）数据，那么，我们一一取掉堆顶，并维护最小堆（最大堆），就可以达到一种排序的效果。我们发现，很多地方都是[<em>2][</em>2+1][/2]等，那么，我们可以用位运算来加快速度。</p>
<p>程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Heap.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Heap.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn=<span class="number">20</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">1</span>&lt;&lt;maxn],n,b[<span class="number">1</span>&lt;&lt;maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_up</span><span class="params">(<span class="keyword">int</span> k,<span class="keyword">int</span> x)</span>  <span class="comment">//建堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> ((k&gt;<span class="number">1</span>) &amp;&amp; (x&lt;a[k&gt;&gt;<span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a[k],a[k&gt;&gt;<span class="number">1</span>]);</span><br><span class="line">        k=k&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a[k]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_down</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x, <span class="keyword">int</span> len)</span>  <span class="comment">//维护堆</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//fout &lt;&lt; k &lt;&lt; ' ' &lt;&lt; x &lt;&lt; ' ' &lt;&lt; len &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((k&lt;&lt;<span class="number">1</span>&lt;=len) &amp;&amp; ((x&gt;a[k&lt;&lt;<span class="number">1</span>]) || (x&gt;a[k&lt;&lt;<span class="number">1</span>+<span class="number">1</span>])))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//fout &lt;&lt; "**" &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s1=k&lt;&lt;<span class="number">1</span>,s2=k&lt;&lt;<span class="number">1</span> | <span class="number">1</span>,s;</span><br><span class="line">        <span class="keyword">if</span> (s2&gt;len) s=s1;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[s1]&lt;a[s2]) s=s1;<span class="keyword">else</span> s=s2;</span><br><span class="line">            &#125;</span><br><span class="line">        swap(a[s],a[k]);</span><br><span class="line">        k=s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Heap_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span>  <span class="comment">//堆排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j=r,m=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=l; i&lt;=r; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b[++m]=a[<span class="number">1</span>];</span><br><span class="line">        a[<span class="number">1</span>]=a[j];</span><br><span class="line">        j--;</span><br><span class="line">        Heap_down(<span class="number">1</span>,a[<span class="number">1</span>],j);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(a,b,<span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t;</span><br><span class="line">        fin &gt;&gt; t;</span><br><span class="line">        Heap_up(i,t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) fout &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    Heap_sort(<span class="number">1</span>,n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>5.11创新班总结</title>
    <url>/Informatics%20In%20Junior/5.11%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天的创新班，学的就是单调队列。</p>
<p>题目：给定一个长度为N的数列，求出每一个区间长度为K的最大值。</p>
<p>样例输入：</p>
<p>8，7，12，5，4，2，16，9，17，8</p>
<p>样例输出：</p>
<p>12，12，12，5，16，16，17，17</p>
<p>传统做法：我们首先想到的就是硬枚举。从第1位枚举到第N-K+1位，再枚举区间K的每一位，得到最大值。但是，时间复杂度为O(N*K)，若数据再大一点，就无法AC了。那怎么办呢？我们发现，比较[8,7,12]与[7,12,5]时，[7,12]就重复了，而且，答案也是12。</p>
<p>思想：单调队列是指一个队列中的数单调递增（或者递减），是一个方便求指定区间极值的一种队列。简单来说，首先我们求得第一个区间的最大值是[12]，然而，这就说明了再以后的区间中，另外两个数[8,7]再也不可能成为最大值，因为比它大的数[12]在[8,7]后面。</p>
<p>维护队列：</p>
<p>对于样例，我们来模拟一下：</p>
<p>i=1：插入8，队列为：（8）       {i=1&lt;3，不输出队首8}</p>
<p>i=2：插入7，队列为：（8，7）    {i=2&lt;3，不输出队首8}</p>
<p>i=3：插入12，队列为：（12，8，7）{12大于7和8，依次删除队尾的7和8，并插入12到队列，且i=3了，故输出队首的12}</p>
<p>i=4：插入5，队列为：（12，5）    {i≥3，输出队首12}</p>
<p>i=5：插入4，队列为：（12，5，4） {i≥3，输出队首12}</p>
<p>i=6：插入2，队列为：（12，5，4，2）{i≥3，2插入后，因为队列中的元素多于了3个，队首的12没用了故被删除，输出此时的队首5，}</p>
<p>i=7：插入16，队列为：（16  5，4，2） {16大于队尾的2、4、5，依次删除2、4、5，并输出队首16}</p>
<p>i=8：插入9，队列为：（16，9）        {i≥3，输出队首16}</p>
<p>i=9：插入17，队列为：（17 16，9）    {i≥3，输出队首17}</p>
<p>i=10：插入8，队列为（17，8）       {i≥3，输出队首17}</p>
<p>程序：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"dandiao.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"dandiao.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x,p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,k;</span><br><span class="line">data b1[<span class="number">100002</span>],b2[<span class="number">100002</span>];</span><br><span class="line"><span class="keyword">int</span> h1=<span class="number">1</span>,t1=<span class="number">1</span>,h2=<span class="number">1</span>,t2=<span class="number">1</span>,a[<span class="number">100002</span>],ans=<span class="number">999999</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin &gt;&gt;n &gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;++i) fin &gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert1</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=t1;</span><br><span class="line">    <span class="keyword">for</span> (;i&gt;=h1 &amp;&amp; x&gt;b1[i].x;--i);</span><br><span class="line">    i++;</span><br><span class="line">    b1[i].x=x;</span><br><span class="line">    b1[i].p=p;</span><br><span class="line">    t1=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert2</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=t2;</span><br><span class="line">    <span class="keyword">for</span> (;i&gt;=h2 &amp;&amp; x&lt;b2[i].x;--i);</span><br><span class="line">    i++;</span><br><span class="line">    b2[i].x=x;</span><br><span class="line">    b2[i].p=p;</span><br><span class="line">    t2=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    b1[<span class="number">1</span>].x=a[<span class="number">1</span>];</span><br><span class="line">    b1[<span class="number">1</span>].p=<span class="number">1</span>;</span><br><span class="line">    b2[<span class="number">1</span>].x=a[<span class="number">1</span>];</span><br><span class="line">    b2[<span class="number">1</span>].p=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i-k+<span class="number">1</span>&gt;b1[h1].p) h1++;</span><br><span class="line">        insert1(a[i],i);</span><br><span class="line">        <span class="keyword">if</span> (i-k+<span class="number">1</span>&gt;b2[h2].p) h2++;</span><br><span class="line">        insert2(a[i],i);</span><br><span class="line">        <span class="keyword">if</span> (ans&gt;(b1[h1].x-b2[h2].x) &amp;&amp; i&gt;=k)</span><br><span class="line">            ans= b1[h1].x-b2[h2].x;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt;ans &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>3.9创新班总结</title>
    <url>/Informatics%20In%20Junior/3.9%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这天创新班的内容，主要的就是两道测试题。尽管这两道测试看上去并不难，实际上，这需要动动脑筋才想得到呢？</p>
<h2 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h2><p>这一道题主要就是讲，有n个数排成一个圈，求从第x个到第y个的和。（如果是x&lt;=y表示从x到y，如果是x&gt;y，则表示从x到n再从1到y）。</p>
<p>很多人一看题目，就知道这道题只需简单模拟一下即可。但是，我们一看到n高达100000，并且有高达100000次计算，最坏情况下，O（n*m），10^10次方，早就超时，那么我们该怎么办呢？我们发现，主要超时地方就是我们要一个数一个数加。</p>
<p>这是，我们要引入前缀和。前缀和，顾名思义，就是一个数前面的所有数字的和。那么，我们用f数组储存一个数的前缀和，即f[i]=f[i-1]+a[i]。那么我们现在有两种情况，一是x≤y；一是x＞y。</p>
<ol>
<li><p>x≤y。f[x]表示a[1]到a[x]的和，f[y]表示a[1]到a[y]的和，a[x]到a[y]不就是f[y]-f[x]吗？</p>
</li>
<li><p>x＞y。（如果是x&lt;=y表示从x到y，如果是x&gt;y，则表示从x到n再从1到y）[原文]，结果不就是f[n]-f[x]+f[y]。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"a.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"a.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">110000</span>],b[<span class="number">110000</span>]=&#123;<span class="number">0</span>&#125;,n,m,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dodo</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span>=<span class="number">-11000000</span>;</span><br><span class="line">    fin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) fin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    b[<span class="number">1</span>]=a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; ++i) b[i]=b[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span> ;i&lt;=m ;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x,y,ans=<span class="number">0</span>;</span><br><span class="line">        fin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">if</span> (x&lt;=y) ans=dodo(x,y); <span class="comment">//①</span></span><br><span class="line">            <span class="keyword">else</span> ans=dodo(x,n)+dodo(<span class="number">1</span>,y); <span class="comment">//②</span></span><br><span class="line">        <span class="keyword">if</span> (ans&gt;<span class="built_in">max</span>) <span class="built_in">max</span>=ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout&lt;&lt;<span class="built_in">max</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dodo</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>(b[r]-b[l<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二题："><a href="#第二题：" class="headerlink" title="第二题："></a>第二题：</h2><p>这一道题，说难不难，说简单也不简单。这一道题主要就是说：有n个数，排成一排（与上一题不同），问有多少段数是11的倍数。</p>
<p>这一道题还是用前缀和来解决。还是老样子，用f数组储存。然后，我们还要开一个数组c，c[i]=f[i]%11，为什么呢？我们需要前缀的余数，就是为了，接下来的计算。例如数据[3,-2,4,6,9,2]，前缀和就是[3,-1,5,11,20,22]，那么前缀和的余数就是[3,1,5,0,9,0],这时我们发现，有两个不相邻的0，我们此时知道，第一个到第四个的和是11p1+q（q不一定是0），第一个到第六个的和是11p2+q，那么第五个到第六个的和不就是11（p2-p1）。换句话说，任意不相邻的两个余数是相等的话，结果就加一。</p>
<p>值得注意的是，我们要默认开头多一个0，即要考虑c[0]=0，因为，我们要考虑从第一个到第x个的情况。</p>
<p>那么，我们可以统计每个余数的出现次数记录在x数组上，根据排列组合，ans+=(x[i]+x[i-1])/2（x[0]要加上开头的0）。</p>
<p>PS：我们可以在输入数据时加上一个较大的11倍数的正整数，如110000，这样可以避免负数有不影响结果。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"b.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"b.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arr[<span class="number">100005</span>];</span><br><span class="line">arr a,b=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> c[<span class="number">15</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> n,sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123; fin&gt;&gt;a[i]; a[i]+=<span class="number">110000</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) b[i]=(b[i<span class="number">-1</span>]+a[i])%<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=n; i++) c[b[i]]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=<span class="number">11</span>; i++) sum+=(c[i]*(c[i]<span class="number">-1</span>)/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*for (int i=1; i&lt;=n; i++)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      if (b[i]==b[i-1]) sum--;*/</span>&#123;Question：究竟是否需要判重呢？如何判重呢？&#125;</span><br><span class="line"></span><br><span class="line">    fout&lt;&lt;sum&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>3.19创新班总结</title>
    <url>/Informatics%20In%20Junior/3.19%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们学习了很多内容，虽然有些辛苦，但是我们会坚持不懈的。这次我们学习了动态数组（向量）、栈等。</p>
<h2 id="一：动态数组（vector）"><a href="#一：动态数组（vector）" class="headerlink" title="一：动态数组（vector）"></a>一：动态数组（vector）</h2><p>其实，vector就是向量的意思，但是，这不是数学和物理学中的向量，局势是什么意思，我也不同，但它的用处可大了。简单来说，就是需要多大空间就开多大空间，是动态的。</p>
<p>①  头文件：#include <vector></p>
<p>②  定义：vector <type> 数组名</p>
<p>③  返回最后一个数据元素的值    v.back()</p>
<p>④  清空向量中的数据    v.clear()</p>
<p>⑤  判断向量是否为空，空则返回 1    v.empty()</p>
<p>⑥  返回第一个数据元素的值    v.front()</p>
<p>⑦  删除最后一个数据元素    v.pop_back()</p>
<p>⑧  将参数作为数据元素插入到向量末尾    v.push_back(对应类型的数据)</p>
<p>⑨  返回向量中数据元素个数    v.size()</p>
<p>⑩  与另一个向量作交换    v.swap()</p>
<p>具体程序将与“栈”知识点结合。</p>
<h2 id="二：栈"><a href="#二：栈" class="headerlink" title="二：栈"></a>二：栈</h2><p>栈是一种数据结构，与队列不同，队列是先进先出，而栈是先进后出，递归正是运用栈来实现的。</p>
<p>括号匹配，就是判断一组括号是否合法。基本思路就是：看到左括号就进栈，看到右括号就判断一下，若是与栈顶的左括号相匹配，就出栈，否则就只接输出不合格。这样，与动态数组正好可以无缝结合。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"括号匹配.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"括号匹配.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">char</span>&gt; f;</span><br><span class="line"><span class="keyword">int</span> l[<span class="number">128</span>];</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">bool</span> yes;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line">    yes=<span class="literal">true</span>;</span><br><span class="line">    f.push_back(<span class="string">'#'</span>);</span><br><span class="line">    l[<span class="string">'('</span>]=<span class="number">1</span>; l[<span class="string">')'</span>]=<span class="number">1</span>;</span><br><span class="line">    l[<span class="string">'['</span>]=<span class="number">2</span>; l[<span class="string">']'</span>]=<span class="number">2</span>;</span><br><span class="line">    l[<span class="string">'&#123;'</span>]=<span class="number">3</span>; l[<span class="string">'&#125;'</span>]=<span class="number">3</span>;</span><br><span class="line">    l[<span class="string">'&lt;'</span>]=<span class="number">4</span>; l[<span class="string">'&gt;'</span>]=<span class="number">4</span>;<span class="comment">//这样就可以转换成数值之间比较，无需一种一种括号比较</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=s.<span class="built_in">size</span>(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="keyword">if</span> ((s[i]==<span class="string">'('</span>) || (s[i]==<span class="string">'['</span>) || (s[i]==<span class="string">'&#123;'</span>) || (s[i]==<span class="string">'&lt;'</span>))</span><br><span class="line">            f.push_back(s[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">if</span> (l[s[i]]==l[f.back()]) f.pop_back();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                yes=<span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin&gt;&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((yes) &amp;&amp; (f.back()==<span class="string">'#'</span>)) </span><br><span class="line">        fout&lt;&lt;<span class="string">"Yes!"</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        fout&lt;&lt;<span class="string">"No!"</span>&lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>顺便在次附上“运算表达式”的程序（之前编的pas，还未来得及转cpp，以后，再会附上cpp）</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span></span><br><span class="line">    ed=<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    s,s1:<span class="keyword">string</span>;</span><br><span class="line">    st:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000</span>] <span class="keyword">of</span> real;</span><br><span class="line">    st2:<span class="keyword">array</span>[<span class="number">0</span>..<span class="number">10000</span>] <span class="keyword">of</span> char;</span><br><span class="line">    l:<span class="keyword">array</span>[<span class="string">'!'</span>..<span class="string">'/'</span>] <span class="keyword">of</span> longint;</span><br><span class="line">    top1,top2,len,i,j,code:longint;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">calc</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    a,b,c:real;</span><br><span class="line">    ch:char;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    a:=st[top1]; dec(top1);</span><br><span class="line">    b:=st[top1]; dec(top1);</span><br><span class="line">    ch:=st2[top2-<span class="number">1</span>]; st2[top2-<span class="number">1</span>]:=st2[top2]; dec(top2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ch <span class="keyword">of</span></span><br><span class="line">        <span class="string">'+'</span>:c:=b+a;</span><br><span class="line">        <span class="string">'-'</span>:c:=b-a;</span><br><span class="line">        <span class="string">'*'</span>:c:=b*a;</span><br><span class="line">        <span class="string">'/'</span>:c:=b/a;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    inc(top1); st[top1]:=c;</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">main</span>;</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    top1:=<span class="number">0</span>; top2:=<span class="number">0</span>;</span><br><span class="line">    fillchar(st,sizeof(st),<span class="number">0</span>);</span><br><span class="line">    fillchar(st2,sizeof(st2),<span class="string">' '</span>);</span><br><span class="line">    s:=<span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    readln(s);</span><br><span class="line">    len:=length(s);</span><br><span class="line">    l[<span class="string">'+'</span>]:=<span class="number">2</span>; l[<span class="string">'-'</span>]:=<span class="number">2</span>;</span><br><span class="line">    l[<span class="string">'*'</span>]:=<span class="number">1</span>; l[<span class="string">'/'</span>]:=<span class="number">1</span>;</span><br><span class="line">    l[<span class="string">'('</span>]:=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    i:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> i&lt;=len <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] <span class="keyword">in</span> [<span class="string">'0'</span>..<span class="string">'9'</span>]) <span class="keyword">or</span> (s[i]=<span class="string">'.'</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            j:=i+<span class="number">1</span>; s1:=s[i];</span><br><span class="line">            <span class="keyword">while</span> ((s[j] <span class="keyword">in</span> [<span class="string">'0'</span>..<span class="string">'9'</span>]) <span class="keyword">or</span> (s[j]=<span class="string">'.'</span>)) <span class="keyword">and</span> (j&lt;=len) <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                s1:=s1+s[j];</span><br><span class="line">                inc(j);</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">            </span><br><span class="line">            i:=j-<span class="number">1</span>;</span><br><span class="line">            inc(top1);</span><br><span class="line">            val(s1,st[top1],code);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i]=<span class="string">'+'</span>) <span class="keyword">or</span> (s[i]=<span class="string">'-'</span>) <span class="keyword">or</span> (s[i]=<span class="string">'*'</span>) <span class="keyword">or</span> (s[i]=<span class="string">'/'</span>) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            inc(top2);</span><br><span class="line">            st2[top2]:=s[i];</span><br><span class="line">            <span class="keyword">while</span> (top2&gt;<span class="number">1</span>) <span class="keyword">and</span> (l[st2[top2]]&gt;=l[st2[top2-<span class="number">1</span>]]) <span class="keyword">do</span> calc;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s[i]=<span class="string">'('</span>) <span class="keyword">and</span> (s[i-<span class="number">1</span>] <span class="keyword">in</span> [<span class="string">'0'</span>..<span class="string">'9'</span>]) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            inc(top2);</span><br><span class="line">            st2[top2]:=<span class="string">'*'</span>;</span><br><span class="line">            <span class="keyword">while</span> (top2&gt;<span class="number">1</span>) <span class="keyword">and</span> (l[st2[top2]]&gt;=l[st2[top2-<span class="number">1</span>]]) <span class="keyword">do</span> calc;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s[i]=<span class="string">'('</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            inc(top2);</span><br><span class="line">            st2[top2]:=s[i];</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> s[i]=<span class="string">')'</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            inc(top2);</span><br><span class="line">            st2[top2]:=s[i];</span><br><span class="line">            <span class="keyword">while</span> (top2&gt;<span class="number">1</span>) <span class="keyword">and</span> (st2[top2-<span class="number">1</span>]&lt;&gt;<span class="string">'('</span>) <span class="keyword">do</span> calc;</span><br><span class="line">            dec(top2,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">        inc(i);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    inc(top2);</span><br><span class="line">    st2[top2]:=<span class="string">')'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (top2&gt;<span class="number">1</span>) <span class="keyword">do</span> calc;</span><br><span class="line"></span><br><span class="line">    writeln(st[top1]:<span class="number">0</span>:ed)</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    writeln(<span class="string">'Calc Module Over!'</span>);</span><br><span class="line">    writeln(<span class="string">'ed='</span>,ed);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="number">1</span>=<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">write</span>(<span class="string">'Please input:'</span>);</span><br><span class="line">        main;</span><br><span class="line">        writeln(<span class="string">'Over!  Next!'</span>);</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"><span class="keyword">END</span>.</span><br></pre></td></tr></table></figure>

<h2 id="三：递归的记忆化"><a href="#三：递归的记忆化" class="headerlink" title="三：递归的记忆化"></a>三：递归的记忆化</h2><p>在递归过程中，经常会出现超时，超空间的情况。我们发现，假设是int f(int x)的函数，x经常会出现多次，那么，我们就可以用一个数组储存每一次，计算过x后的f(x)的值。这样，我们就可以大大的减少时间复杂度。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"递归记忆化.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"递归记忆化.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> k)</span></span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">1002</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    fout&lt;&lt;fac(n)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">fac</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans;</span><br><span class="line">    <span class="keyword">if</span>(k==<span class="number">0</span>||k==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a[k]!=<span class="number">0</span>) <span class="keyword">return</span> a[k];<span class="comment">//记忆化过程①</span></span><br><span class="line">    <span class="keyword">else</span> ans=fac(k<span class="number">-1</span>)+fac(k<span class="number">-2</span>);</span><br><span class="line">    a[k]=ans; <span class="comment">//记忆化过程②</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四：二叉树"><a href="#四：二叉树" class="headerlink" title="四：二叉树"></a>四：二叉树</h2><p>二叉树，就是一个根结点，连接两个结点，分别是左结点和右结点，一次类推，形成一个全新的数据结构。</p>
<p>二叉树还有几个特点，就是：</p>
<p>①  有n个点，就有n-1条边</p>
<p>②  绝对无环</p>
<p>③  绝对连通</p>
<p>④  最多有2n-1（n层）</p>
<p>再次，不得不提的是，二叉树的左序遍历，中序遍历，后序遍历。</p>
<p>① 左序遍历，就是先遍历左子树，遍历根，再遍历右子树，一次递归下去。</p>
<p>② 中序遍历，就是先遍历根，遍历左子树，再遍历右子树，一次递归下去。</p>
<p>③ 右序遍历，就是先遍历右子树，遍历根，再遍历左子树，一次递归下去。</p>
<h2 id="五：卡特兰数"><a href="#五：卡特兰数" class="headerlink" title="五：卡特兰数"></a>五：卡特兰数</h2><p>卡特兰数，就是 ，再许多问题上都很有用。</p>
<h2 id="六：错排问题"><a href="#六：错排问题" class="headerlink" title="六：错排问题"></a>六：错排问题</h2><p>题目如下：有n个信封，n封信，如果这些信封全都装错，那么一共会有多少种情况？</p>
<p>```c++<br>#include <fstream><br>using namespace std;</p>
<p>ifstream fin(“错牌问题.in”);<br>ofstream fout(“错牌问题.out”);</p>
<p>void read();<br>void write();</p>
<p>long long f[1000];<br>int n;</p>
<p>int main()<br>{<br>    read();</p>
<pre><code>f[0]=0; f[1]=1;
for (int i=2; i!=n; ++i) f[i]=i*(f[i-1]+f[i-2]);

write();
return 0;</code></pre><p>}</p>
<p>void read()<br>{<br>    fin&gt;&gt;n;<br>}</p>
<p>void write()<br>{<br>    for (int i=0; i!=n; ++i) fout&lt;&lt;f[i]&lt;&lt;”  “;<br>    fout&lt;&lt;’\n’;<br>}</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>7.19夏令营总结</title>
    <url>/Informatics%20In%20Junior/7.19%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们仍然是做题目，深入动态规划，而我，则着重于区间动态规划。虽然今天只做了一道题，但对于这道题，我认为还是有些难度的。</p>
<h2 id="数字游戏"><a href="#数字游戏" class="headerlink" title="数字游戏"></a>数字游戏</h2><p>【题目】在你面前有一圈整数（一共n个），你要按顺序将其分为m个部分，各部分内的数字相加，相加所得的m个结果对10取模后再相乘，最终得到一个数k。游戏的要求是使你所得的k最大或者最小。</p>
<p>2</p>
<p>4</p>
<p>-1</p>
<p>3</p>
<p>例如，对于下面这圈数字（n=4，m=2）：<br>2013年07月22日 - 邱俊斌 - 邱俊斌<br>当要求最小值时，((2-1) mod 10)×((4+3) mod 10)=1×7=7，要求最大值时，为((2+4+3) mod 10)×(-1 mod 10)=9×9=81。特别值得注意的是，无论是负数还是正数，对10取模的结果均为非负值。</p>
<p>求最大值和最小值。</p>
<p>【输入】</p>
<p>4 2</p>
<p>4</p>
<p>3</p>
<p>-1</p>
<p>2</p>
<p>【输出】</p>
<p>7</p>
<p>81</p>
<p>【分析】看上去，这一道题似乎无从下手。但明显的，我们知道这一道题目，我们可以用动态规划来下手。但是，而动态规划的核心，就在于子问题。</p>
<p>在不考虑环形结构的情况下，以样例为例[4,3,-1,2]，因为我们要把这4个数分成两份，所以</p>
<p>我们可以单独把[4]分1份，那么[3,-1,2]分成1份，就是子问题（下图红色部分），</p>
<p>也可以把[4,3]分1份，那么[-1,2] 分成1份，就是子问题（下图蓝色部分），</p>
<p>也可以把[4,3,-1]分1份，那么[2] 分成1份，就是子问题（下图绿色部分）。</p>
<p>他不见了。</p>
<p>子问题是解决了，那么状态转移方程也可以列出来了，按照石子归并的方法，用F[i][j]表示从i到j的m个区间的最大值（最小值）。但是，我们总觉得少了什么东西，就是如何表示它的份数呢？</p>
<p>没错，我们需要开多一维（事实上，我们可以优化掉的），F[i][j][k]表示从第i位到第j位，分成k个区间的最大值，或最小值，由上可知状态转移方程，如下：</p>
<p>sum[i][j]表示从第i位到第j位的总和后，模10，如果模10后为负数，应自加10。</p>
<p>对于环形的问题，我们完全可以用能量项链的方法，复制一段在数据后面，每一段都进行一次DP。</p>
<p>接下来要注意的就是</p>
<p>① 就像石子归并，以长度分阶段，枚举左端点，确定右端点</p>
<p>② sum[i][j]可以预处理，sum[i][j]=sum[i][j-1]+num[j],sum[0][0]=num[0]。</p>
<p>③ DP前，如果是求最大值，那么DP数组F应清为负无穷，求最小值则相反</p>
<p>④ 当区间为1时，F[i][j][1]=sum[i][j]</p>
<p>⑤ 疑问：在DP时，为什么枚举区间K时，要放在最外层，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> K=<span class="number">2</span>;K&lt;=m; K++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=K; len&lt;=n; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L=x; L&lt;=n-len+x; L++) &#123;</span><br><span class="line">            <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid=L; mid!=R; mid++)</span><br><span class="line">                F[L][R][K]=<span class="built_in">max</span>(F[L][R][K],F[mid+<span class="number">1</span>][R][K<span class="number">-1</span>] * sum[L][mid]);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>而不能放在循环最四层</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len=K; len&lt;=n; len++)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> L=x; L&lt;=n-len+x; L++) &#123;</span><br><span class="line">        <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> mid=L; mid!=R; mid++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> K=<span class="number">2</span>;K&lt;=(len-mid+<span class="number">1</span>) &amp;&amp; K&lt;=m; K++)</span><br><span class="line">                F[L][R][K]=<span class="built_in">max</span>(F[L][R][K],F[mid+<span class="number">1</span>][R][K<span class="number">-1</span>] * sum[L][mid]);</span><br><span class="line">        &#125;（实践可以）</span><br></pre></td></tr></table></figure>

<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Game.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Game.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double_maxn 100+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxm 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum[double_maxn][double_maxn];</span><br><span class="line"><span class="keyword">int</span> num[double_maxn],n,m;</span><br><span class="line"><span class="keyword">int</span> F[double_maxn][double_maxn][maxm];</span><br><span class="line"><span class="keyword">int</span> maxx=-oo,minn=oo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        fin &gt;&gt; num[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perpare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        num[i+n]=num[i];</span><br><span class="line"></span><br><span class="line">    sum[<span class="number">0</span>][<span class="number">0</span>]=num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=<span class="number">2</span>*n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j!=<span class="number">2</span>*n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (!(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>))</span><br><span class="line">                sum[i][j]=(sum[i][j<span class="number">-1</span>]+num[j]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=<span class="number">2</span>*n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j!=<span class="number">2</span>*n; ++j) &#123;</span><br><span class="line">            sum[i][j]=(sum[i][j]+oo) % <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=<span class="number">2</span>*n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j!=<span class="number">2</span>*n; ++j) &#123;</span><br><span class="line">            F[i][j][<span class="number">1</span>]=sum[i][j];<span class="comment">//区间为1时，实际上值为sum[i][j]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=m; k++)</span><br><span class="line">                F[i][j][k]=-oo;<span class="comment">//清为负无穷</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> K=<span class="number">2</span>;K&lt;=m; K++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len=K; len&lt;=n; len++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> L=x; L&lt;=n-len+x; L++) &#123;</span><br><span class="line">                <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid=L; mid!=R; mid++)</span><br><span class="line">                    F[L][R][K]=<span class="built_in">max</span>(F[L][R][K],F[mid+<span class="number">1</span>][R][K<span class="number">-1</span>] * sum[L][mid]);<span class="comment">//状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F[x][y<span class="number">-1</span>][m];<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=<span class="number">2</span>*n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j!=<span class="number">2</span>*n; ++j) &#123;</span><br><span class="line">            F[i][j][<span class="number">1</span>]=sum[i][j];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k=<span class="number">2</span>; k&lt;=m; k++)</span><br><span class="line">                F[i][j][k]=oo; <span class="comment">//清为正无穷</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> K=<span class="number">2</span>;K&lt;=m; K++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> L=x; L&lt;=n-len+x; L++) &#123;</span><br><span class="line">                <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid=L; mid!=R; mid++)</span><br><span class="line">                    F[L][R][K]=<span class="built_in">min</span>(F[L][R][K],F[mid+<span class="number">1</span>][R][K<span class="number">-1</span>] * sum[L][mid]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F[x][y<span class="number">-1</span>][m]; <span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fout &lt;&lt; minn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; maxx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();<span class="comment">//输入</span></span><br><span class="line"></span><br><span class="line">    perpare();<span class="comment">//解决环形问题</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t!=n; ++t) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1=work1(t,t+n);<span class="comment">//求最大</span></span><br><span class="line">        <span class="keyword">int</span> tmp2=work2(t,t+n);<span class="comment">//求最小</span></span><br><span class="line">        maxx=<span class="built_in">max</span>(maxx,tmp1);</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,tmp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>();<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【优化】</p>
<p>① 其实，求最大最小值的DP，极为类似，我们可以优化成一段DP</p>
<p>② 求sum[i][j]，我们可以用前缀和的方法，用ans[i]表示前i位的和，那么sum[i][j]=ans[j]-ans[i-1]。那么，空间上可以降一维，求和时，时间上，也可以降一维。</p>
<p>③ 其实，我们是先DP区间为2是的情况；然后再DP区间为3的情况……那么，我们完全可用滚动数组的方式，把F数组降一维。尽管那一维，只有10位，但是，这种思想有时是值得肯定的。</p>
<p>【优化程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Game.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Game.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double_maxn 100+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DP[double_maxn][double_maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[double_maxn],sum[double_maxn];</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line">DP maxF,minF,maxF_new,minF_new;</span><br><span class="line"><span class="keyword">int</span> maxx=-oo,minn=oo;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i) &#123;</span><br><span class="line">        fin &gt;&gt; num[i];</span><br><span class="line">        num[i]=(num[i]+oo) % <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perpare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        num[i+n]=num[i];</span><br><span class="line"></span><br><span class="line">    sum[<span class="number">0</span>]=num[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i!=<span class="number">2</span>*n; ++i)</span><br><span class="line">        sum[i]=(sum[i<span class="number">-1</span>]+num[i]) % <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==y) <span class="keyword">return</span> num[x];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> (sum[y]-sum[x<span class="number">-1</span>]+oo) % <span class="number">10</span>;</span><br><span class="line">&#125;<span class="comment">//使用前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> &amp;ans1, <span class="keyword">int</span> &amp;ans2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=x; i!=y; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j!=y; ++j) &#123;</span><br><span class="line">            maxF[i][j]=<span class="built_in">get</span>(i,j);</span><br><span class="line">            minF[i][j]=<span class="built_in">get</span>(i,j);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> K=<span class="number">2</span>;K&lt;=m; K++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=x; i!=y; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j!=y; ++j) &#123;</span><br><span class="line">                maxF_new[i][j]=-oo;</span><br><span class="line">                minF_new[i][j]=oo;</span><br><span class="line">            &#125;<span class="comment">//边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len=K; len&lt;=n; len++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> L=x; L&lt;=n-len+x; L++) &#123;</span><br><span class="line">                <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> mid=L; mid!=R; mid++) &#123;</span><br><span class="line">                    maxF_new[L][R]=<span class="built_in">max</span>(maxF_new[L][R],maxF[mid+<span class="number">1</span>][R] * <span class="built_in">get</span>(L,mid));</span><br><span class="line"></span><br><span class="line">                    minF_new[L][R]=<span class="built_in">min</span>(minF_new[L][R],minF[mid+<span class="number">1</span>][R] * <span class="built_in">get</span>(L,mid));<span class="comment">//状态转移方程</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memcpy</span>(maxF,maxF_new,<span class="keyword">sizeof</span>(maxF));</span><br><span class="line">        <span class="built_in">memcpy</span>(minF,minF_new,<span class="keyword">sizeof</span>(minF));<span class="comment">//更新滚动数组</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans1=maxF[x][y<span class="number">-1</span>];</span><br><span class="line">    ans2=minF[x][y<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fout &lt;&lt; minn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; maxx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    perpare();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t!=n; ++t) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp1,tmp2;</span><br><span class="line">        work(t,t+n,tmp1,tmp2);</span><br><span class="line"></span><br><span class="line">        maxx=<span class="built_in">max</span>(maxx,tmp1);</span><br><span class="line">        minn=<span class="built_in">min</span>(minn,tmp2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>3.2创新班总结</title>
    <url>/Informatics%20In%20Junior/3.2%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="一：约瑟夫问题"><a href="#一：约瑟夫问题" class="headerlink" title="一：约瑟夫问题"></a>一：约瑟夫问题</h2><p>约瑟夫问题，简单来说，就是有N个人，从一号开始，1,2,…，m，1,2,…，m，每报号m的人就被淘汰，那么，最后的那个人是谁呢？</p>
<p>我们可以建立一个数组，标记每一个人连接的下一个是谁。然后不断循环，一旦数到m时，这个人的前一个就连到这个人的后一个，直到这个人连接的是自己，那么，我们就知道了最后剩下的那个人是谁了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"约瑟夫问题.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"约瑟夫问题.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,p;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++) a[i]=i+<span class="number">1</span>;</span><br><span class="line">    a[n]=<span class="number">1</span>;</span><br><span class="line">    p=n;</span><br><span class="line">    work();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;m;j++) p=a[p];</span><br><span class="line">        <span class="keyword">if</span>(i==n) fout&lt;&lt;<span class="string">"real ans:"</span>;</span><br><span class="line">        fout&lt;&lt;a[p]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        a[p]=a[a[p]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二：归并排序"><a href="#二：归并排序" class="headerlink" title="二：归并排序"></a>二：归并排序</h2><p>归并排序，就是“归”和“并”。我们将这一个无序数组不断二分，然后将这二分后的有序数组段两两合并。</p>
<p>二分，就是不断递归，但如何合并呢？假设[1,3,5,8]和[2,4,6,7]进行合并。我们先看[1]和[2]，明显[1]更小，然后我们再看[3]和[2]，明显[2]更小，[3]和[4]比较，[4]小些……以此类推。最后，我们可以得出[1,2,3,4,5,6,7,8]。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> mid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;x,<span class="keyword">int</span> &amp;y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000005</span>],b[<span class="number">10000005</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[<span class="number">0</span>];i++) <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    mergesort(<span class="number">1</span>,a[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=a[<span class="number">0</span>];i++) <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r,<span class="keyword">int</span> mid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=l,j=mid+<span class="number">1</span>,p=l;</span><br><span class="line">    <span class="keyword">for</span>(;p&lt;=r;p++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((i&lt;=mid)&amp;&amp;((j&gt;r)||(a[i]&gt;a[j])))</span><br><span class="line">        &#123;</span><br><span class="line">            b[p]=a[i]; </span><br><span class="line">            i++;             </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            b[p]=a[j];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=l;k&lt;=r;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[k]=b[k];</span><br><span class="line">        b[k]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(r!=l)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">        mergesort(l,mid);</span><br><span class="line">        mergesort(mid+<span class="number">1</span>,r);</span><br><span class="line">        merge(l,r,mid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三：宽度搜索"><a href="#三：宽度搜索" class="headerlink" title="三：宽度搜索"></a>三：宽度搜索</h2><p>宽度搜索，其实还有一个名称，叫做“灌水法”。其实在此，我们要引出一个叫队列的数据类型。队列犹如一个数组，先进那么就现出，后进就后出。假设有一个点a1，它连接b1，b2，那么我们就让b1，b2进队列，然后让b1出列，b1连接着c1，c2，那么c1，c2入队列。此时队列为b2，c1，c2。b2出列，b2连接c3，c4，那么让c3，c4入队列，以此类推……</p>
<h2 id="四：拓扑排序"><a href="#四：拓扑排序" class="headerlink" title="四：拓扑排序"></a>四：拓扑排序</h2><p>图，也是一个数据类型，有许多点，每个点之间都有连线。没有方向的叫做无向图，而有方向的就是有向图。</p>
<p>那么，对于一个有向图，我们可不可以对每一个点进行排序呢？其实这叫做拓扑排序。对于每一个点来说，有几条线连着它，就说它有几个度。那么，几条线指着它，就有几个入度；射出几条线条，就有几个出度。每一个入度为零的，就排在前面，然后撤去射出线条，在判断，放在后面，以此类推……</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>7.20测试，7.21调试总结</title>
    <url>/Informatics%20In%20Junior/7.20%E6%B5%8B%E8%AF%95%EF%BC%8C7.21%E8%B0%83%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>这一次测试，是COCI测试，成绩一般，但收获还是有的。</p>
<h2 id="第1题-组队的数量（Timsko）"><a href="#第1题-组队的数量（Timsko）" class="headerlink" title="第1题 组队的数量（Timsko）"></a>第1题 组队的数量（Timsko）</h2><p>【题目】有N个女生，M个男生，每2个女生和1个男生组成一队，先要取走K个人当志愿者，问最多还能组多少队？</p>
<p>【分析】作为第一题，难度不大。首先我们不考虑当志愿者的情况，那么枚举一下最多能有多少组。对于剩下的人，全部去当志愿者。如果还有志愿者名额，那么，名额每自减3，组数减1，直到名额没有了。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Timsko.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Timsko.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,K,group;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; M &gt;&gt; K;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; group&lt;=M &amp;&amp; group*<span class="number">2</span>&lt;=N; group++);<span class="comment">//先枚举组数</span></span><br><span class="line"></span><br><span class="line">    group--;<span class="comment">//由于算多了一组，要自减一</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left=(N+M)<span class="number">-3</span>*group;<span class="comment">//剩下</span></span><br><span class="line">    K-=left;<span class="comment">//减去剩下</span></span><br><span class="line">    <span class="keyword">for</span> (; K&gt;<span class="number">0</span>; K-=<span class="number">3</span>,group--);<span class="comment">//名额减3，组数减1</span></span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; group &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第2题-突击考试（Profesor）"><a href="#第2题-突击考试（Profesor）" class="headerlink" title="第2题 突击考试（Profesor）"></a>第2题 突击考试（Profesor）</h2><p>【题目】有N组数，每组数有A，B两个数，A，B在[1..5]的范围内。当连续的L行都含有K这个数时，问L最大为多少，以及K。（当L相等，K取最小）</p>
<p>【分析】题目有些难以理解。这还是一道模拟题，开一个数组，枚举每一个数的大小（只有[1..5]），看看这个数在N组数中，连续的组数最大为多少。最后输出最大即可。</p>
<p>要注意，A[i]==B[i]的情况，不要叠加，而有重复。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Profesor.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Profesor.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> max_grade 5+5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> A[maxn] , B[maxn];</span><br><span class="line"><span class="keyword">int</span> X[max_grade] , Y[max_grade];<span class="comment">//X储存当前连续最大为多少，Y储存一直最大为多少</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != N; ++ i)</span><br><span class="line">        fin &gt;&gt; A[i] &gt;&gt; B[i];</span><br><span class="line"></span><br><span class="line">    X[A[<span class="number">0</span>]] = Y[A[<span class="number">0</span>]] = X[B[<span class="number">0</span>]] = Y[B[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i != N; ++ i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == A[i<span class="number">-1</span>] || A[i] == B[i<span class="number">-1</span>]) X[A[i]] ++;</span><br><span class="line">        <span class="keyword">else</span> X[A[i]] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])</span><br><span class="line">            <span class="keyword">if</span> ((B[i] == A[i<span class="number">-1</span>] || B[i] == B[i<span class="number">-1</span>]) &amp;&amp; A[i] != B[i])</span><br><span class="line">                X[B[i]] ++;<span class="comment">//要注意A[i]==B[i]的情况</span></span><br><span class="line">            <span class="keyword">else</span> X[B[i]] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (X[A[i]] &gt; Y[A[i]]) Y[A[i]] = X[A[i]];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (X[B[i]] &gt; Y[B[i]]) Y[B[i]] = X[B[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_L=-oo,min_grade=oo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> grade = <span class="number">1</span>; grade &lt;= <span class="number">5</span>; grade ++)</span><br><span class="line">        <span class="keyword">if</span> ((Y[grade] &gt; max_L) || ((Y[grade] == max_L) &amp;&amp; (grade &lt; min_grade))) &#123;</span><br><span class="line">            max_L=Y[grade];</span><br><span class="line">            min_grade=grade;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; max_L &lt;&lt; <span class="string">' '</span> &lt;&lt; min_grade &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第3题-幸运数字（Sretan）"><a href="#第3题-幸运数字（Sretan）" class="headerlink" title="第3题 幸运数字（Sretan）"></a>第3题 幸运数字（Sretan）</h2><p>【题目】我们认为只包含4和7的数字为幸运数字，比如4, 7, 44, 47, 74…。</p>
<p>现在对于给定的N，请你求出第N个幸运数字。</p>
<p>【分析】4和7，其实我们可以看成0和1。这题明显是找规律。我们先从特殊到一般：</p>
<p>7.20测试，7.21调试总结 - 邱俊斌 - 邱俊斌</p>
<p>第一列是二进制数，其实没什么关系，只是作为对照。</p>
<p>第二列是序号N。</p>
<p>第三列是实际的幸运数字。</p>
<p>第四列是’4’对应’0’，’7’对应’1’的情况</p>
<p>我们看第四列，以28为例，我们可以先确定28的长度。我们发现，[1..2]是一位，[3..6]是两位，[7..14]是三位，[15..30]是四位，以此类推。对于长度为k的情况下，它的范围就是[2k-1..2k+1-2]。这样，枚举k即可。</p>
<p>我们又发现，在[2k-1..2k+1-2]的范围内，前一半是以0开头，后一半以1开头，这样，我们就确定了头一位数字了。</p>
<p>去掉头一位数字，后面的数字就是子问题了。我们找规律，又发现，在[2k-1..2k+1-2]的范围内，前一半区域的子问题就是，N-2k-1；后一半区域的子问题就是，N-2k。</p>
<p>边界就是N为0和1的情况，单独列出即可。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Sretan.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Sretan.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxl 1000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> F[maxl];</span><br><span class="line"><span class="keyword">int</span> N , len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = N;</span><br><span class="line">    <span class="keyword">for</span> (; tmp &gt; <span class="number">2</span>; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> P = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ((P - <span class="number">1</span>) &lt;&lt; <span class="number">1</span>) &lt; tmp; P &lt;&lt;= <span class="number">1</span>);枚举P</span><br><span class="line">        <span class="keyword">int</span> tmp_P = P;</span><br><span class="line">        <span class="keyword">int</span> Q = (-- P) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp_Q = tmp_P &lt;&lt; <span class="number">1</span>;<span class="comment">//P为当前区域上边界，Q为当前区域下边界</span></span><br><span class="line">        <span class="keyword">int</span> mid = ((Q - P + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + P;</span><br><span class="line">        <span class="keyword">bool</span> up_down = (tmp &lt; mid);<span class="comment">//求是在上区域还是在下区域</span></span><br><span class="line">        <span class="keyword">if</span> (up_down) F[++ len] = <span class="string">'4'</span>;</span><br><span class="line">        <span class="keyword">else</span> F[++ len] = <span class="string">'7'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (up_down) tmp -= (tmp_P &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> tmp -= (tmp_Q &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">2</span>) F[++ len] = <span class="string">'7'</span>;</span><br><span class="line">    <span class="keyword">if</span> (tmp == <span class="number">1</span>) F[++ len] = <span class="string">'4'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">        fout &lt;&lt; F[i];</span><br><span class="line">    fout &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第4题-分糖果（Ljutnja）"><a href="#第4题-分糖果（Ljutnja）" class="headerlink" title="第4题 分糖果（Ljutnja）"></a>第4题 分糖果（Ljutnja）</h2><p>【题目】有N个小孩，有M颗糖。每个小孩有期望的糖果数a[i]，糖果不够分，每个小孩的生气指数为，他没有得到糖果数的平方。问最小生气指数之和。</p>
<p>【分析】要是生气指数和最小，那么他们的没有的到的糖唐数尽可能的平均。证明：</p>
<p>所以，糖果尽可能给需求量大的，那么，生气指数之和相对会更小。</p>
<p>7.20测试，7.21调试总结 - 邱俊斌 - 邱俊斌<br>我们先从大到小排序，枚举每一个数i，它与前一个数i+1有差距diff，若M&gt;i<em>diff，那么M自减i</em>diff；若不够，那么，对于剩下的M，我们尽可能给前i名小孩M/i颗糖，剩下的M%i余数r，就给前r名小孩M/i+1颗糖，枚举剩下的每个孩子有多少颗糖，最后结算即可。</p>
<p>要注意，由于题目要求答案可能高达264-1，所以，需要用到unsigned long long</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Ljutnja.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Ljutnja.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 100000+10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ULL;<span class="comment">//注意数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line">ULL hope[maxn];</span><br><span class="line">ULL sum;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; M &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != N; ++ i)</span><br><span class="line">        fin &gt;&gt; hope[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ULL tmp = M;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != N; ++ i) &#123;</span><br><span class="line">        ULL diff = hope[i] - hope[i+<span class="number">1</span>];</span><br><span class="line">        ULL cnt = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">bool</span> ok = (tmp &gt;= cnt * diff);</span><br><span class="line">        <span class="keyword">if</span> (ok) tmp -= cnt * diff;<span class="comment">//看看剩下的M颗糖是否够</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ULL P = hope[i] - (tmp / cnt);</span><br><span class="line">            ULL rest = tmp % cnt;</span><br><span class="line">            sum = (P - <span class="number">1</span>) * (P - <span class="number">1</span>) * rest + (cnt - rest) * P * P;<span class="comment">//要注意，如P2要写成P*P，不要写成pow（P,2），因为会有精度误差</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j != N; ++ j)</span><br><span class="line">                sum += hope[j]*hope[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fout &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    sort(hope+<span class="number">0</span>,hope+N,cmp);</span><br><span class="line"></span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第5题-编辑文本（Tabovi）"><a href="#第5题-编辑文本（Tabovi）" class="headerlink" title="第5题 编辑文本（Tabovi）"></a>第5题 编辑文本（Tabovi）</h2><p>【题目】有N行字符，每行字符前有P[i]空格，我们想每行有K[i]个空格。现在我们可以任意选H行，每行前加一个空格或减少一个空格（算作一步）。问最少需要多少步？</p>
<p>【分析】其实就是有N个数（有正有负），通过如题目的操作，问最少需要多少步？</p>
<p>如何操作呢？其实，我们发现，对于这么一列数，我们找到</p>
<p>7.20测试，7.21调试总结 - 邱俊斌 - 邱俊斌</p>
<p>如图，一列数可以按正负，分成许多区域，找到这区域的最小值，每一个数同时减去这个最小值。那么这个区域就分成了两个部分，最小值那个数就变成了0。递归左边和右边的部分，再累加每一个最小值，即可。</p>
<p>要注意的是，当求负数区域时，是与求证正数区域，相反。</p>
<p>当然，如果不用递归，用一个栈也可以做。</p>
<p>而且，求这段区域的最小值（最大值），我们除了直接枚举，还可以用胜者树的办法，或是用RMQ的办法（会另外讲）。</p>
<p>【程序】</p>
<p>```c++<br>#include <fstream><br>using namespace std;</p>
<p>ifstream fin(“Tabovi.in”);<br>ofstream fout(“Tabovi.out”);</p>
<p>#define maxn 1000+10<br>#define oo 100000000</p>
<p>int start[maxn],end[maxn],move[maxn],n;<br>int ans;</p>
<p>void read() {<br>    fin &gt;&gt; n;<br>    for (int i = 0; i != n; ++ i)<br>        fin &gt;&gt; start[i];</p>
<pre><code>for (int i = 0; i != n; ++ i)
    fin &gt;&gt; end[i];

for (int i = 0; i != n; ++ i)
    move[i] = end[i] - start[i];</code></pre><p>}</p>
<p>int get_min(int x, int y) {<br>    int tmp = oo,pos = 0;</p>
<pre><code>for (int k = x; k != y; ++ k)
    if (move[k] &lt; tmp) {
        tmp = move[k];
        pos = k;
    }

return pos;</code></pre><p>}</p>
<p>int solve1(int x, int y, int sub) {//sub储存当前区域每一个数已自减多少（无需真的枚举去减，只需用变量储存，计算是注意些，即可）<br>    if ((y - x) == 1) return move[x] - sub;<br>    if (x == y) return 0; //边界<br>    int loca_min = get_min(x,y);//求最小<br>    int tmp = move[loca_min] - sub;</p>
<pre><code>return solve1(x,loca_min,tmp + sub) + solve1(loca_min+1,y,tmp + sub) + tmp;</code></pre><p>}</p>
<p>int get_max(int x, int y) {<br>    int tmp = -oo,pos = 0;</p>
<pre><code>for (int k = x; k != y; ++ k)
    if (move[k] &gt; tmp) {
        tmp = move[k];
        pos = k;
    }

return pos;</code></pre><p>}</p>
<p>int solve2(int x, int y, int add) {<br>    if ((y - x) == 1) return abs(move[x] + add);<br>    if (x == y) return 0;<br>    int loca_max = get_max(x,y);<br>    int tmp = move[loca_max] + add;</p>
<pre><code>return solve2(x,loca_max,abs(tmp - add)) + solve2(loca_max+1,y,abs(tmp - add)) + abs(tmp);</code></pre><p>}</p>
<p>void write() {<br>    fout &lt;&lt; ans &lt;&lt; endl;<br>}</p>
<p>int main() {<br>    read();</p>
<pre><code>int symbol = (move[0] &gt; 0) ? 1 : 2;
if (move[0] == 0) symbol = 0;
int begin = 0;
for (int i = 0; i &lt;= n; ++ i) {
    int symbol_new = (move[i] &gt; 0) ? 1 : 2;

    if (move[i] == 0) symbol_new = 0;
    if (symbol != symbol_new) {//判断是否有正负交错
        if (move[begin] != 0) {
            if (symbol == 1)
                ans += solve1(begin,i,0);//正的情况
            else
                ans += solve2(begin,i,0);//负的情况
        }
        begin = i;
        symbol = symbol_new;//更替
    }
}

write();
return 0;</code></pre><p>}</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>7.18夏令营总结</title>
    <url>/Informatics%20In%20Junior/7.18%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们并没有学习什么新知识，只是对昨天的知识复习了一下，并做了一些练习。</p>
<h2 id="取数游戏"><a href="#取数游戏" class="headerlink" title="取数游戏"></a>取数游戏</h2><p>【题目】小明和小红在玩游戏，现在有一列数，每一个人轮流从两边取数，知道取玩。那么每人的分数就是他所取的数之和。小明先取，问能赢小红多少分？</p>
<p>【输入】</p>
<p>5</p>
<p>6 5 7 8 4</p>
<p>【输出】</p>
<p>4</p>
<p>【思路】一排数列，小明可以从两头取，去那边好呢？我们假设F[i][j]表示从i到j的数列小明可以赢多少。若取左边，那么子问题就成了F[i+1][j]；若取右边，则子问题就变成了F[i][j-1]，那么，很明显这是区间DP了。</p>
<p>就像石子归并一样，以长度分阶段，而状态转移方程也分析出来了，就是</p>
<p>F[i][j]=max(a[i]-F[i+1][j],a[j]-F[i][j-1])</p>
<p>也许有人会疑问，为什么要用a[i]减去F[i+1][j]呢？因为，F[i][j]是表示i到j小明赢多少，去了左边，接下来小红就得去一个，小明就赢不了F[i+1][j]的分数了，反而要输去，所以要减去。去右边的情况也同理。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"access_game.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"access_game.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[maxn],F[maxn][maxn],n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        fin &gt;&gt; num[i];<span class="comment">//输入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        F[i][i]=num[i];<span class="comment">//对于只有一个数，小明拿了这一个数，就赢得了，这一个数字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len++)<span class="comment">//长度来分阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;=n-len; l++) &#123;<span class="comment">//枚举左端点</span></span><br><span class="line">            <span class="keyword">int</span> r=l+len<span class="number">-1</span>;<span class="comment">//枚举右端点</span></span><br><span class="line">            F[l][r]=<span class="built_in">max</span>(num[l]-F[l+<span class="number">1</span>][r],num[r]-F[l][r<span class="number">-1</span>]);<span class="comment">//状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; F[<span class="number">0</span>][n<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="能量项链"><a href="#能量项链" class="headerlink" title="能量项链"></a>能量项链</h2><p>【题目】有N颗珠子连在一起，成为一条项链。没颗珠子都有有个标记（数字），每颗珠子的头标记是前一颗珠子的尾标记，每颗珠子的尾标记是后一颗珠子的头标记，如[2,3][3,5][5,10][10,2]。相邻的两颗珠子可以可并成一颗珠子，并发出能量，如[2,3][3,5]，那么能量值为2<em>3</em>5=30，直到只剩下一颗珠子。问最大发出的能量是多少？</p>
<p>【输入】<br>2 3 5 10</p>
<p>【输出】<br>710</p>
<p>【思路】这题目看上去很长，其实题意跟石子归并相差无几。难点只有一个，这是环形的。唤醒并不好处理，怎么办呢？</p>
<p>做好的办法就是化曲为直。将它铺成一条直线，复制一段在后边，然后分段进行区间DP，如图：</p>
<p>他不见了。</p>
<p>这时，模块化的有点就凸显出来了，把一段区间DP做成一个模块，就更好了。</p>
<p>Tips：其实，我们可以开一个数组，每一个节点都贮存它的头标记和尾标记，虽然有点麻烦，但是在做区间DP时，计算会更加清晰。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"energy.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"energy.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> double_maxn 200+20</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l,r;</span><br><span class="line">&#125;pearl[double_maxn]; <span class="comment">//储存成，有头标记和尾标记的形式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> maxx=<span class="number">-10000000</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> F[double_maxn][double_maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> tmp[double_maxn];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        fin &gt;&gt; tmp[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">        pearl[i].l=tmp[i];</span><br><span class="line">        pearl[i].r=tmp[i+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pearl[n<span class="number">-1</span>].l=tmp[n<span class="number">-1</span>];</span><br><span class="line">    pearl[n<span class="number">-1</span>].r=tmp[<span class="number">0</span>];<span class="comment">//转化成，储存头标记和尾标记的形式，特别的要注意最后一个珠子的尾标记</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perpare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        pearl[i+n]=pearl[i];<span class="comment">//复制一段在后面</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> h=<span class="number">0</span>; h&lt;=double_maxn; h++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> g=<span class="number">0</span>; g&lt;=double_maxn; g++)</span><br><span class="line">            <span class="keyword">if</span> (h==g) F[h][g]=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span> F[h][g]=<span class="number">-100000000</span>;<span class="comment">//初始化，赋值为负无穷</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; len++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> L=x; L&lt;=n-len+x; L++) &#123;</span><br><span class="line">            <span class="keyword">int</span> R=L+len<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid=L; mid!=R; mid++)</span><br><span class="line">                F[L][R]=<span class="built_in">max</span>(F[L][R],F[L][mid]+F[mid+<span class="number">1</span>][R]+pearl[L].l*pearl[mid].r*pearl[R].r);<span class="comment">//状态转移方程</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F[x][y<span class="number">-1</span>];<span class="comment">//返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fout &lt;&lt; maxx &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">read</span>();<span class="comment">//读入</span></span><br><span class="line"></span><br><span class="line">    perpare();<span class="comment">//储存头标记和尾标记</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t!=n; ++t) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> tmp=work(t,t+n);<span class="comment">//做一次区间DP</span></span><br><span class="line">        maxx=<span class="built_in">max</span>(maxx,tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>();<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>8.18创新班总结</title>
    <url>/Informatics%20In%20Junior/8.18%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们学习了二分查找这一主要内容。二分查去找，之前也有涉及到。但是，今天我们对二分查找，进一步的熟悉。</p>
<p>【例题】给定一列长度为N（8.18创新班总结 - 邱俊斌 - 邱俊斌）的从小到大的数列，给定一个数x，问x在数列的下标为多少？</p>
<p>【输入】</p>
<p>5</p>
<p>1 5 7 8 10</p>
<p>8</p>
<p>【输出】</p>
<p>4</p>
<p>【二分查找】二分查找，其实就是把一段数列，分成平均的两段，在对这两个数列进行查找。</p>
<p>由于数列是有序的，因此，一段数列符合如图的规则：</p>
<p>他不见了。</p>
<p>他不见了。</p>
<p>，如果我们要找的书x&gt;mid的话，那么x就只可能在[mid+1,high]这一段之中，不可能在[low,mid]之中了。<br>以此类推，知道low≥high结束，答案就是low（或是high，因为此时low==high）。</p>
<p>【题目1】已知</p>
<p>他不见了。</p>
<p>,给定time和c，问实数n最大为多少？</p>
<p>【分析】其实，这一道题并不复杂，其实就是枚举n，但是，我们并不是直接枚举，而是二分地枚举。</p>
<p>n一定在【0,2000000000】之间，取</p>
<p>他不见了。</p>
<p>，如果</p>
<p>他不见了。</p>
<p>那么，就一定在区间【low，mid-1】中，反之，在【mid+1，high】。如果刚好等于time，那么就是答案。或者说，只需二分100次，1000次，得到的答案，已经极为接近答案了。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"sorting.in"</span>)</span></span>;</span><br><span class="line"><span class="comment">//ofstream fout("sorting.out");</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c,tim;</span><br><span class="line"><span class="keyword">double</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; c &gt;&gt; tim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> lo=<span class="number">0</span>, hi=<span class="number">2000000000</span>;<span class="comment">//都是double型的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++) &#123;<span class="comment">//循环100次</span></span><br><span class="line">        <span class="keyword">double</span> mid=(lo+hi)/<span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c*mid*log2(mid)&lt;=tim)<span class="comment">//二分</span></span><br><span class="line">            lo=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hi=mid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=lo;<span class="comment">//答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.9f\n"</span>,ans);<span class="comment">//输出要注意，进度为9位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"sorting.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    outit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">【题目<span class="number">2</span>】有长度为N的一列，分成M个部分，问数值和最大的那一部分最小为多少？</span><br><span class="line"></span><br><span class="line">【输入】</span><br><span class="line"></span><br><span class="line"><span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span> <span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">50</span> <span class="number">60</span> <span class="number">70</span> <span class="number">80</span> <span class="number">90</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">【输出】</span><br><span class="line"></span><br><span class="line"><span class="number">170</span></span><br><span class="line"></span><br><span class="line">【分析】其实，这一道题就是要将数列尽可能的平均分配。其实，这一道题我们也是二分答案。</span><br><span class="line"></span><br><span class="line">从区间[<span class="number">0</span>,<span class="number">15000</span>]开始（边界可以设置大一些），二分mid，枚举数列的每一个数，一个个累加。当累加器大于mid时，就说明之前的工作量，是一个部分。这是，累加器等于当前值，继续枚举，依此类推。</span><br><span class="line"></span><br><span class="line">如果需要的部分大于M，那么说明，答案应该比mid要大，因此，low=mid+<span class="number">1</span>。反之，high=mid。</span><br><span class="line"></span><br><span class="line">【程序】</span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">#include &lt;fstream&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"folders.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"folders.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N,M,ans;</span><br><span class="line"><span class="keyword">int</span> data[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i)</span><br><span class="line">        fin &gt;&gt; data[i];</span><br><span class="line">    fin &gt;&gt; M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ok</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> curw=<span class="number">1</span>;<span class="comment">//累计工人数</span></span><br><span class="line">    <span class="keyword">int</span> cflo=<span class="number">0</span>;<span class="comment">//累加器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cflo+data[i]&gt;x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data[i]&gt;x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            </span><br><span class="line">            curw++;</span><br><span class="line">            cflo=data[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cflo+=data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> curw&lt;=M;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lo=<span class="number">0</span>, hi=<span class="number">20000</span>;</span><br><span class="line">    <span class="keyword">for</span> (; lo&lt;hi; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid=(lo+hi)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (ok(mid))<span class="comment">//判断mid是否可行；二分</span></span><br><span class="line">            hi=mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            lo=mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans=lo;<span class="comment">//答案</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">outit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fout &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init();</span><br><span class="line"></span><br><span class="line">    work();</span><br><span class="line"></span><br><span class="line">    outit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>7.24夏令营总结</title>
    <url>/Informatics%20In%20Junior/7.24%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们有初步学习到了一种新的动态规划，那就是状态压缩的集合动态规划。而且，我们还复习了一些二进制的位运算。</p>
<h2 id="二进制的位运算："><a href="#二进制的位运算：" class="headerlink" title="二进制的位运算："></a>二进制的位运算：</h2><p>平常我们表示一个数是，经常用int型。其实，他还有一个用途，那就是表示一个32位的布尔集合。换句话讲，就是讲一个int型的数，转化成一个二进制数，再进行位运算。</p>
<p>例如，我们用一个数s表示一个32位的布尔集合，如[01001101000101110110101110100011]，是其中一个状态：。</p>
<p>① 假如我们需要取出集合中的第k位，那么就是s &amp; (1&lt;&lt;k)</p>
<p>② 假如我们需要将集合的第k位变成1，那么就是s + (1&lt;&lt;k)</p>
<p>③ 假如我们需要将集合的第k位变成0，那么就是s - (1&lt;&lt;k)。</p>
<h2 id="状态压缩："><a href="#状态压缩：" class="headerlink" title="状态压缩："></a>状态压缩：</h2><p>通常，我们表示一个状态时，由于状态数实在太多，放不下，特别是动态规划，怎么办呢？</p>
<p>刚刚我们讲到，可以用一个int型表示一个32位的布尔集合，如果用int型，需要4字节；如果用数组表示，需要32字节，整整省了8倍的空间。而且，用位运算，可以解决绝大部分的操作。同样可以表示这么多状态，，空间上却可以节省8倍。</p>
<h2 id="例题：最短路径问题"><a href="#例题：最短路径问题" class="headerlink" title="例题：最短路径问题"></a>例题：最短路径问题</h2><p>【问题】给定一个图，包括边的长度，从任意一点出发，要求走遍所有点，问最短路径？</p>
<p>【输入】</p>
<p>5 6</p>
<p>0 4 2</p>
<p>0 3 3</p>
<p>1 4 3</p>
<p>1 3 1</p>
<p>1 2 2</p>
<p>2 3 4</p>
<p>【输出】</p>
<p>dfs:10</p>
<p>【分析dfs】假如这一道题，使用搜索左，我们应该怎么找子问题呢？</p>
<p>按照我们平时的思路，应该是开一个布尔集合，实时记录当前的那些点用了，那些点没用，然后记录当前搜索到的点，记录当前长度，当每一个点都搜到了就退出。</p>
<p>然而，如果这么编的话，是失败的。因为，我们无法进行记忆化搜索，也就是找不到子问题。</p>
<p>那么，子问题是什么呢？如图：</p>
<p>他不见了。</p>
<p>首先，假如我们搜到了点v，那么与之相连的点有p1，p2，p3，p4，那么，子问题就是，把点v加进集合s后（表示点v已经走过），从点pi出发最短路径问题（不包括集合s内的点）。这里有一个限制条件，就是，如果点pi在集合s内（即点pi已经走过），那么，我们就无需计算从点pi出发的子问题。</p>
<p>如果集合内，表示只有一个点还可以走，那么，我们就可以结束了，返回0即可。因为从该点出发，已经不能走到别的点了，因为别的点都已经走过了。</p>
<p>这样，我们就可以用记忆化了。用F[s][v]表示s这一状态的集合，从v点出发的最短路径，这样，就可以记忆化了。</p>
<p>关于布尔集合，我们已经知道可以用一个int型表示。我们用1表示还可以用，0表示已经用了，点的序号从0到N-1，那么搜索开始时就应该为（(1&lt;&lt;N)-1），1&lt;&lt;N，那么集合为<a href="N个0">1000…000</a>，再减1，就变成[1111…1111]（N-1个1）。</p>
<p>还有一点，那就是由于要走遍所有点，因此，从哪一点出发都没有问题，因此，我们为了方便，就从点0出发。</p>
<p>【分析dp】关于dp有一点说明，那就就是做dp题目的时候，都有两种方向，一种就是大问题调用小问题，还有一种是小问题改进大问题。</p>
<p>首先是大问题调用小问题。与搜索的记忆化类似，用用G[s][p]表示p这一状态的集合，从v点出发的最短路径，那么</p>
<p>他不见了。</p>
<p>我们枚举s和p，q是与p相连的点。从点q出发的最短路径问题是子问题，那么从点q出发的子问题，表示就是G[s-(1&lt;&lt;p)][q]，其中，s-(1&lt;&lt;p)是指点p已经走过了，要删去。</p>
<p>注意的是，枚举点p和点q时，要注意点p和点q在集合s中是尚未走过的。</p>
<p>而小问题改进大问题则差别不大，主要在于状态转移方程，为</p>
<p>他不见了。</p>
<p>同样是枚举s，p，q，不过点q有些不同，在于点q一定要已经走过了。小问题就是G[s][p]，而大问题就是G[s+(1&lt;&lt;q)][q]，如图。其中，s+(1&lt;&lt;q)是指向前推，搜索到点q，因此集合s要表示点q尚未走过。</p>
<p>他不见了。</p>
<p>【程序】说明：dfs正确，dp有错，但思想正确。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"setdp.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"setdp.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; adj[maxn];<span class="comment">//储存相连的点</span></span><br><span class="line"><span class="keyword">int</span> dist[maxn][maxn]; <span class="comment">//储存边长的长度</span></span><br><span class="line"><span class="keyword">int</span> F[<span class="number">1</span>&lt;&lt;maxn][maxn], G[<span class="number">1</span>&lt;&lt;maxn][maxn];</span><br><span class="line"><span class="keyword">int</span> N, M;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">empty_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=(<span class="number">1</span>&lt;&lt;N); ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=N; ++j)</span><br><span class="line">            F[i][j] = G[i][j] = oo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">in_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=M; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        fin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">        adj[a].push_back(b);</span><br><span class="line">        adj[b].push_back(a);</span><br><span class="line">        dist[a][b] = dist[b][a] = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    empty_();<span class="comment">//清空数组</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chk</span><span class="params">(<span class="keyword">int</span> Q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i)</span><br><span class="line">        <span class="keyword">if</span> (Q &amp; (<span class="number">1</span>&lt;&lt;i)) sum++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (chk(s)==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//检查边界</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (F[s][v]!=oo) <span class="keyword">return</span> F[s][v];<span class="comment">//记忆化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minn=oo;</span><br><span class="line">    s -= (<span class="number">1</span>&lt;&lt;v);<span class="comment">//v已经走过了</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=adj[v].<span class="built_in">size</span>(); ++i) &#123;<span class="comment">//枚举每一个与v相连的点</span></span><br><span class="line">        <span class="keyword">int</span> p=adj[v][i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s &amp; (<span class="number">1</span>&lt;&lt;p))<span class="comment">//点p在集合s内（即点p尚未走过）</span></span><br><span class="line">            minn &lt;?= dfs(s,p)+dist[v][p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> F[s][v] = minn;<span class="comment">//记忆化、返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    empty_();</span><br><span class="line"></span><br><span class="line">    G[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">1</span>; s!=(<span class="number">1</span>&lt;&lt;N); s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">1</span>; p!=N; ++p)</span><br><span class="line">            <span class="keyword">if</span> (s &amp; (<span class="number">1</span>&lt;&lt;p))<span class="comment">//点p尚未走过</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=adj[p].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    <span class="keyword">int</span> q=adj[p][j];<span class="comment">// 枚举每一个与p相连的点</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (s &amp;(<span class="number">1</span>&lt;&lt;q)) <span class="comment">//点q尚未走过</span></span><br><span class="line">                        G[s][p] &lt;?= G[s-(<span class="number">1</span>&lt;&lt;p)][q]+dist[p][q];<span class="comment">//状态转移方程</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G[(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    empty_();</span><br><span class="line"></span><br><span class="line">    G[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s=<span class="number">1</span>; s!=(<span class="number">1</span>&lt;&lt;N); s++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p!=N; ++p)</span><br><span class="line">            <span class="keyword">if</span> (s &amp; (<span class="number">1</span>&lt;&lt;p)) <span class="comment">//点p尚未走过</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=adj[p].<span class="built_in">size</span>(); ++j) &#123;<span class="comment">// 枚举每一个与p相连的点</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">int</span> q=adj[p][j];</span><br><span class="line">                    <span class="keyword">if</span> ( !(s &amp; (<span class="number">1</span>&lt;&lt;q) ) <span class="comment">//点q已经走过</span></span><br><span class="line"></span><br><span class="line">                        G[s+(<span class="number">1</span>&lt;&lt;q)][q] &lt;?= G[s][p]+dist[p][q]; <span class="comment">//状态转移方程</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> G[(<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main() &#123;</span><br><span class="line">    in_();<span class="comment">//读入</span></span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; <span class="string">"dfs:"</span> &lt;&lt; dfs((<span class="number">1</span>&lt;&lt;N)<span class="number">-1</span>,<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; <span class="string">"dp1:"</span> &lt;&lt; dp1() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    fout &lt;&lt; <span class="string">"dp2:"</span> &lt;&lt; dp2() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>7.25夏令营总结</title>
    <url>/Informatics%20In%20Junior/7.25%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们学习了一样新的东西，那就是<strong>树状数组</strong>。何为树状数组呢？</p>
<p>【问题】我们定义 N 个整型变量组成的数组 v[1..N]，每次操作有两种：</p>
<p>① 将v[idx] 增加 det</p>
<p>② 求 7.25夏令营总结 - 邱俊斌 - 邱俊斌</p>
<p>【想法】我们怎么解决好呢？</p>
<p>用数组直接操作，操作①O(1)，操作②O(n2)。明显超时。</p>
<p>用线段树，代码量大，而且，容易出错。</p>
<p>用新学的RMQ，我们先DP求出F[i][k]表示从第i位出发的2k的和，那么求区间[1..i]的合适，就先找出k，使得1&lt;2k≤i。得出F[1][k]后，继续求区间[2k+1,i]的和，知道2k+1=i时结束。这样，我们可以很好地求和。</p>
<p>但是，我们如果改变一个的值，那该怎么办呢？需要修改的地方太多了。而且，RMQ是静态的。</p>
<p>【引入】和RMQ的想法一样，如图，建立起F[i][k]这样一个数组，就像图中的区间一样。</p>
<p>他不见了。</p>
<p>然而，我们发现，其实，红色区域的地方，其实是没有什么用的。比如说[2]的那一块小的红色区域，可以用[1..2]的区域减去[1]区域。那么，去掉红色区域，就清晰多了。</p>
<p>现在，我们发现，我们可以用点i表示其中一个区间。比如说：</p>
<p>点1表示区间[1]；</p>
<p>点2表示区间[1..2]；</p>
<p>点3表示区间[3]；</p>
<p>点4表示区间[1..4];</p>
<p>……</p>
<p>他不见了。</p>
<p>【低位技术lowbit】树状数组，与之息息相关的，就是低位技术。</p>
<p>所谓低位技术，就是取出一个二进制数，从右往左数，第一个以的位置。如[10010]，那么，我们需要一种技术，取出[00010]。</p>
<p>① I and (I xor (I-1))。我们假设有这么一个数[<em>…</em>10…0]（<em>代表任意数），那么减1，就变成了[</em>…*01…1]，在两者异或以下，就变成了[0…011…1]，在最初的I进行与运算，则变成[0…010..0]，达到了我们想要的目的。</p>
<p>② I and (~I+1)即I and (-I)。一个数[<em>…</em>10…0]，取反变成<a href="#为*的取反">#…#01…1</a>,加1得[#…#10…0]，与运算得[0…010…0]，同样达到了我们想要的目的。</p>
<p>【修改】假如，我们修改点6，那么，我们需要修改区间[5..6]和[1..8]；假如我们修改点4，那么我们需要修改区间[1..4][1..8]。这其中有什么规律呢？</p>
<p>规律在于二进制。6的二进制是110。那么首先，我们要修改点6的值，即区间[5..6]。接着110的lowbit，就是10，110+10=1000，即8，那么，我们需要修改点8的值，即区间[1..8]。最后，1000的lowbit是1000，相加为10000，即16，超过了N，退出。</p>
<p>以4为例。4的二进制是100.首先要修改点[4]，即区间[1..4]。然后100的lowbit为100，100+100=1000,即8，那么，我们需要修改点8的值，即区间[1..8]。最后，1000+1000=10000相加，超过了N，退出。</p>
<p>这样，时间复杂度是</p>
<p>他不见了。</p>
<p>。</p>
<p>【求和】同样道理，若求[1..6]的和，就是求点6和点4的和，即区间[5..6]和[1..4]的和。同样是二进制，6的二进制是110。因此，先加上点6的值。110的lowbit是10，这次是相减，110-10=100，即4，加上点4的值。100-100=0，等于0，退出。</p>
<p>求[1..4]也同样。4的二进制是100，因此要加上点4的值。100-100=0，等于0，退出。</p>
<p>这样，时间复杂度也是</p>
<p>他不见了。</p>
<p>。</p>
<p>【初始化】起初，我是不知道该如何初始化的。但是，转念一想，说是插入，不就是将第i个值增加输入的值吗？</p>
<p>【程序】</p>
<p>```c++<br>#include <fstream><br>using namespace std;</p>
<p>ifstream fin(“Binary_Indexed_Trees.in”);<br>ofstream fout(“Binary_Indexed_Trees.out”);</p>
<p>#define maxn 100002</p>
<p>int F[maxn], N, M;</p>
<p>int lowbit_(int x) {<br>    return x &amp; (-x);<br>}//低位技术</p>
<p>void add_(int idx, int x) {<br>    for (; idx&lt;=N; idx+=lowbit_(idx))//加上idx的低位<br>        F[idx] += x;<br>}</p>
<p>void in_() {<br>    fin &gt;&gt; N &gt;&gt; M;<br>    for (int i=1; i&lt;=N; i++) {<br>        int a;<br>        fin &gt;&gt; a;<br>        add_(i, a);//初始化，无非就是在idx增加一个值<br>    }<br>}</p>
<p>int sum_(int idx) {<br>    int s=0;<br>    for (; idx&gt;0; idx-=lowbit_(idx)) //减去idx的低位<br>        s += F[idx];</p>
<pre><code>return s;</code></pre><p>}</p>
<p>int main() {<br>    in_();</p>
<pre><code>for (int i=1; i&lt;=M; i++) {
    char symbol;
    int pos, val;
    fin &gt;&gt; symbol &gt;&gt; pos;
    if (symbol == &apos;a&apos;) { //判断操作标志
        fin &gt;&gt; val;
        add_(pos, val);//修改
    }
    else
        fout &lt;&lt; sum_(pos) &lt;&lt; endl;//求和
}

return 0;</code></pre><p>}</p>
<p>【感受】其实，树状数组代码短，速度快，常数小，在求和方面有着极为重要的低位，需要我们更好地去掌握。</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>不高兴的津津unhappy</title>
    <url>/Informatics%20In%20Junior/%E4%B8%8D%E9%AB%98%E5%85%B4%E7%9A%84%E6%B4%A5%E6%B4%A5unhappy/</url>
    <content><![CDATA[<p>【问题描述】</p>
<p>津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且，上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。</p>
<p>【输入文件】</p>
<p>输入文件unhappy.in包括七行数据，分别表示周一到周日的日程安排。每行包括两个小于10的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。</p>
<p>【输出文件】</p>
<p>输出文件unhappy.out包括一行，这一行只包含一个数字。如果不会不高兴则输出0，如果会则输出最不高兴的是周几(用1,2,3,4,5,6,7分别表示周一，周二，周三，周四，周五，周六，周日)。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的—天。</p>
<h2 id="2012-1-16-星期一"><a href="#2012-1-16-星期一" class="headerlink" title="2012-1-16 星期一"></a>2012-1-16 星期一</h2><p>一看题，不太明白，再看，原来是道简单的不能再简单的题了，是一道大小比较的题目。我主要是设8为原点（因为题目说：一天上课超过八个小时），超过为正，不超为负，在大小比较。</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">7</span>,<span class="number">1</span>..<span class="number">3</span>] <span class="keyword">of</span> integer;</span><br><span class="line">    i,j,mun,max:integer;</span><br><span class="line">    <span class="comment">//a[I,3]用于存放超过数值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    assign(input,<span class="string">'unhappy.in'</span>); reset(input);</span><br><span class="line">    assign(output,<span class="string">'unhappy.out'</span>); rewrite(output);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> <span class="number">7</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">for</span> j:=<span class="number">1</span> <span class="keyword">to</span> <span class="number">2</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">read</span>(a[i,j]);</span><br><span class="line">    a[i,<span class="number">3</span>]:=a[i,<span class="number">1</span>]+a[i,<span class="number">2</span>]-<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    mun:=a[<span class="number">1</span>,<span class="number">3</span>]; max:=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">2</span> <span class="keyword">to</span> <span class="number">7</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> a[i,<span class="number">3</span>]&gt;mun <span class="keyword">then</span> <span class="keyword">begin</span> mun:=a[i,<span class="number">3</span>]; max:=i; <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    writeln(max);</span><br><span class="line"></span><br><span class="line">    close(input);</span><br><span class="line">    close(output);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>关于RMQ的总结</title>
    <url>/Informatics%20In%20Junior/%E5%85%B3%E4%BA%8ERMQ%E7%9A%84%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><strong>RMQ</strong>是英文Range Maximum(Minimum) Query的缩写，顾名思义是用来求某个区间内的最大值或最小值，通常用在要多次询问一些区间的最值的问题中。（资料）</p>
<p>首先，RMQ的原理也是动态规划，需要预先处理。优点在于速度快，但缺点也很明显，就是局限于静态，不同于胜者树。</p>
<p>对于一段区间[L,R]，我们可以将其划分成两个区域，如图所示：</p>
<p>他不见了。</p>
<p>那么，求这两个区域的最大值，这两个区域的最大值的最大值，不就是区间[i..j]的最大值吗？因此这两个区域就是子问题了。</p>
<p>而至于k，若长度len=j-i+1,那么要使得2k&lt;len≤2k+1。当然，求k，我们可以开一个数组Log，Log[i]表示长度为i时，k为多少。</p>
<p>那么，我们设F[i][k]表示第i为后2k的数中，最大值是多少。这样，</p>
<p>他不见了。</p>
<p>给出区间x和y，就可以直接求出区间[x..y]的最大值为</p>
<p>他不见了。</p>
<p>他不见了。</p>
<p>所以，这是一个区间DP，以长度划分阶段，类似于石子归并。</p>
<p>【程序】</p>
<p>```c++<br>#include <fstream><br>using namespace std;</p>
<p>ifstream fin(“RMQ.in”);<br>ofstream fout(“RMQ.out”);</p>
<p>#define maxn 10000<br>#define max_Log 100</p>
<p>int N,M;<br>int num[maxn],Log[maxn];<br>int F[maxn][max_Log];</p>
<p>int perpare() {<br>    int k=0 ,now=1;<br>    for (int i=1; i&lt;=N; ++i) {<br>        if (i == (now&lt;&lt;1)) {<br>            k++;<br>            now&lt;&lt;=1;<br>            Log[i]=k;<br>        }<br>        else<br>            Log[i]=k;<br>    }<br>}</p>
<p>int work() {<br>    for (int i=1; i&lt;=N; ++i)<br>        F[i][0]=num[i];</p>
<pre><code>for (int k=1; k&lt;=Log[N]; ++k)
    for (int i=1; i&lt;=N; ++i)
        F[i][k]=max(F[i][k-1],F[i+(1&lt;&lt;(k-1))][k-1]);//状态转移方程</code></pre><p>}</p>
<p>int solve(int x, int y) {<br>    int tmp=Log[y-x+1];</p>
<pre><code>return max(F[x][tmp],F[(y+1)-(1&lt;&lt;tmp)][tmp]);</code></pre><p>}</p>
<p>int main() {<br>    fin &gt;&gt; N &gt;&gt; M;<br>    for (int i=1; i&lt;=N; ++i)<br>        fin &gt;&gt; num[i];</p>
<pre><code>perpare();//用数组Log[i]计算得出log2i的值

work();//预处理F数组

for (int t=0; t!=M; ++t) {
    int i ,j;
    fin &gt;&gt; i &gt;&gt; j;
    fout &lt;&lt; solve(i,j) &lt;&lt; endl;//直接解决
}

return 0;</code></pre><p>}</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>二进制数表示</title>
    <url>/Informatics%20In%20Junior/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h2 id="2012-1-16-星期一"><a href="#2012-1-16-星期一" class="headerlink" title="2012-1-16 星期一"></a>2012-1-16 星期一</h2><p>刚开始，见到了题目，我就想到要用递归思想，因为2的n次冥中，多出用到了一对括号。</p>
<p>第一时间，我就疑问，例如：10=23+21，那么3和2是怎么的出来的呢？我想：把变量n以1,2,3,4的方式增加，直到2的n次方大于a（原数），那么n-1，a-2的n次方，以此类推，直到a=0。由于题目说只能出现2（2），2,2（0）这几个组合，所以就单独拿出来输出（那字符串顶替是为了调试更方便查看），当n&gt;2是，递归cf(n)。</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">cf</span><span class="params">(a:longint)</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    k,t:longint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">   <span class="comment">// 一开始，我另外自定义函数进行乘方计算，但到了较大的数时，竟然超时，只好改变算法。</span></span><br><span class="line"></span><br><span class="line">        k:=<span class="number">1</span>; t:=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> k&lt;=a <span class="keyword">do</span> <span class="keyword">begin</span> t:=t+<span class="number">1</span>; k:=k*<span class="number">2</span>; <span class="keyword">end</span>;</span><br><span class="line">        k:=k <span class="keyword">div</span> <span class="number">2</span>; t:=t-<span class="number">1</span>;</span><br><span class="line">        a:=a-k;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> t <span class="keyword">of</span></span><br><span class="line">            <span class="number">0</span>:st:=st+<span class="string">'2(0)'</span>;</span><br><span class="line">            <span class="number">1</span>:st:=st+<span class="string">'2'</span>;</span><br><span class="line">            <span class="number">2</span>:st:=st+<span class="string">'2(2)'</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            st:=st+<span class="string">'2('</span>;</span><br><span class="line">            <span class="comment">//我发现，最后时总舵了一个“）”，所以就在最后一层递归中不加括号。（s为计算递归层数）。</span></span><br><span class="line">            s:=s+<span class="number">1</span>;</span><br><span class="line">            cf(t);</span><br><span class="line">            s:=s-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a=<span class="number">0</span>) <span class="keyword">and</span> (s=<span class="number">1</span>) <span class="keyword">then</span> <span class="keyword">exit</span>;</span><br><span class="line">    <span class="keyword">if</span> a=<span class="number">0</span> <span class="keyword">then</span> st:=st+<span class="string">')'</span> <span class="keyword">else</span> st:=st+<span class="string">'+'</span>;</span><br><span class="line">    <span class="keyword">until</span> a=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">end</span>;<span class="comment">//递归过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    s:=<span class="number">1</span>; readln(a); cf(a); writeln(st);</span><br><span class="line"><span class="keyword">end</span>.<span class="comment">//主程序</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>7.23夏令营总结</title>
    <url>/Informatics%20In%20Junior/7.23%E5%A4%8F%E4%BB%A4%E8%90%A5%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们主要学习了有关树状动态规划的初步学习。这是一种典型的DP，也是一种常用的DP。</p>
<h2 id="树状动态规划："><a href="#树状动态规划：" class="headerlink" title="树状动态规划："></a>树状动态规划：</h2><p>所谓树状动态规划，就是一种动态规划，是建立在树的动态规划。通常是给一棵树，要求以最少的代价（或取得最大收益）完成给定的操作。（资料）</p>
<p>其实，通常来说，树形动态规划与区间动态规划有类似的地方。区间DP时，当每几个区间进行合并时，建立起之间的关系图时，这就是一棵树。</p>
<p>树形动态规划，与其他动态规划，一样，无非也就一下几点：</p>
<ol>
<li><p>确立状态：几乎所以的问题都要保存以某结点为根的子树的情况，但是要根据具体问题考虑是否要加维，加几维，如何加维。</p>
</li>
<li><p>状态转移：状态转移的变化比较多，要根据具体问题具体分析，这也是本文例题分析的重点。</p>
</li>
<li><p>算法实现：由于树的结构，使用记忆化搜索比较容易实现。</p>
</li>
</ol>
<h2 id="例题1：二叉苹果树"><a href="#例题1：二叉苹果树" class="headerlink" title="例题1：二叉苹果树"></a>例题1：二叉苹果树</h2><p>【题目】给定一棵二叉树（只分二叉），每条枝干之间有苹果，要求去掉一些枝干，只留下K条枝干，问最多可以留下几个苹果？</p>
<p>【输入】</p>
<p>5 2</p>
<p>1 3 1</p>
<p>1 4 10</p>
<p>2 3 20</p>
<p>3 5 20</p>
<p>【输出】</p>
<p>21</p>
<p>他不见了。</p>
<p>【分析】首先，我们寻找突破口。如果用贪心，但我们却找不到一种恰当的方法。用搜索，当然可以。</p>
<p>首先，我们要找到子问题，搜索才可以进行下去，</p>
<p>他不见了。</p>
<p>以1为根结点需要留下K条枝干，那么它的子问题就是它左右两个子树，以2为根结点的树，以及以3为根结点的树。</p>
<p>那么，我们枚举左右两颗子树分别需要留下多少枝干。</p>
<p>① 若左子树留下0条枝干（默认砍掉节点1和2之间的枝干，也就是整个左子树砍掉），右子树留下K条枝干，那么子问题就是，右子树留下K-1条枝干的子问题。至于K要减1，是因为节点1和3之间的枝干，已经留下了，故要减1。</p>
<p>② 若左子树留下1条枝干，右子树留下K-1条枝干，那么子问题就是，左子树留下1-1=0条枝干，右子树留下K-1-1=K-2条枝干。因为节点1和2，节点1和3，之间的枝干，已经默认这两条枝干留下了。</p>
<p>③ 若左子树留下i条枝干，右子树留下K-i条枝干，那么子问题就是，左子树留下i-1条枝干，右子树留下K-i-1条枝干。</p>
<p>④ 若左子树留下K条枝干，右子树留下0条枝干（默认砍掉节点1和3之间的枝干，也就是整个右子树砍掉），那么子问题就是，左子树留下K-1条枝干的子问题。</p>
<p>⑤ 依此类推。</p>
<p>左右两个子树运行回来的结果，加上节点1和2之间的枝干的苹果树（i！=0），以及节点1和3之间的枝干的苹果树（i！=K），枚举每一次的最大值，就是结果。</p>
<p>如果运行到了叶节点，怎么办呢？没关系。我们知道，叶节点，一定是没有孩子的。首先我们判断当前节点有没有孩子，没有的话，当前节点就是叶节点。而叶节点是没有孩子与之相连的，因此，以叶节点为根的树，只能留下0条枝干。若K！=0，返回负无穷即可。</p>
<p>【注意点】</p>
<p>首先就是树的存储。我们没有学习链表，但vector是一个不错的选择。vector[i]表示以i为父节点，与i相连的节点（包括父节点）。读入时，若为a连上b，不仅要vector[a].push_back(b)还vector [b].push_back(a)。</p>
<p>然后就是边的权值的储存。vector[i]=[j1,jk,jm],表示i点与j1点，jk点，jm点相连，那么我们用vector类型的w[i]=[c1，ck，cm]，表示i与j1相连时的权值是c1，i与jk相连时的权值是ck，i与jm相连时的权值是cm。j与c是位置是一一对应的。</p>
<p>dfs时，假如i点与j点之间的连线权值是c（i是根结点），那么，我们可以将c储存在节点j中（另开数组），这样，就可以很好地表示权值了。</p>
<p>最后就是dfs时的记忆化。具体的就不说了，只需，储存当前节点，留下K条枝干，可留下最多苹果的值即可。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"binary_apple_tree.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"binary_apple_tree.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000+10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 100000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; adj[maxn];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; w[maxn];</span><br><span class="line"><span class="keyword">int</span> F[maxn][<span class="number">102</span>];</span><br><span class="line"><span class="keyword">int</span> cost[maxn];</span><br><span class="line"><span class="keyword">int</span> N,K;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> a ,b ,c;</span><br><span class="line">       fin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">       adj[a].push_back(b);</span><br><span class="line">       adj[b].push_back(a);</span><br><span class="line">       w[a].push_back(c);</span><br><span class="line">       w[b].push_back(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=maxn; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;=<span class="number">102</span>; ++j)</span><br><span class="line">            F[i][j]=-oo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> fa, <span class="keyword">int</span> root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> son[<span class="number">2</span>],s=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=adj[root].<span class="built_in">size</span>(); ++i)<span class="comment">//找当前节点的孩子</span></span><br><span class="line">        <span class="keyword">if</span> (adj[root][i]!=fa) &#123;<span class="comment">//它的孩子不能是父节点</span></span><br><span class="line">            son[s++]=adj[root][i];<span class="comment">//孩子加1</span></span><br><span class="line">            cost[adj[root][i]]=w[root][i];把边权值储存在孩子上</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (k&lt;=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//如果只留0条枝干（即什么都不留），那么一个苹果也没有</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s==<span class="number">0</span>) <span class="keyword">return</span> -oo;<span class="comment">//叶节点的情况</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (F[root][k]!=-oo) <span class="keyword">return</span> F[root][k];<span class="comment">//记忆化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxx=-oo+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=k; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> s1=<span class="number">0</span>,s2=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;<span class="number">0</span>)</span><br><span class="line">            s1=dfs(root,son[<span class="number">0</span>],i<span class="number">-1</span>)+cost[son[<span class="number">0</span>]];<span class="comment">//左子树的情况</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k-i&gt;<span class="number">0</span> &amp;&amp; son[<span class="number">1</span>]!=<span class="number">0</span>)</span><br><span class="line">          s2=dfs(root,son[<span class="number">1</span>],k-i<span class="number">-1</span>)+cost[son[<span class="number">1</span>]];<span class="comment">//右子树的情况</span></span><br><span class="line"></span><br><span class="line">        maxx=(s1+s2&gt;maxx)?s1+s2:maxx;<span class="comment">//求最大值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    F[root][k]=maxx;<span class="comment">//记忆化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    in_();<span class="comment">//读入，留意注意点部分</span></span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; dfs(<span class="number">-1</span>,<span class="number">1</span>,K) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="例题5：战略游戏"><a href="#例题5：战略游戏" class="headerlink" title="例题5：战略游戏"></a>例题5：战略游戏</h2><p>【题目】给定一棵树，每一个点可以放上一个士兵，也可以不放。如果放上一个士兵，那么他可以看到，与之相连的所有边。问，在所有边都能看到的情况下，最少需要多少士兵？</p>
<p>【输入】</p>
<p>4</p>
<p>0 1 1</p>
<p>1 2 2 3</p>
<p>2 0</p>
<p>3 0</p>
<p>【输出】</p>
<p>1</p>
<p>【分析】我们还是一样，先找子问题。其实这一道题，无非就是权衡一个点放还是不放。</p>
<p>我们用F[i][0]表示节点i不放士兵的情况，F[i][1]表示节点i放士兵的情况。</p>
<p>如果放，如图：</p>
<p>他不见了。</p>
<p>那么他的两个孩子，或是不放，没有什么所谓。所以，我们算两个还子放或是不放的最优值之和，加1，不就是结果吗？即：</p>
<p>他不见了。</p>
<p>如果不放，如图：</p>
<p>他不见了。</p>
<p>那么，它的孩子就一定要放。如果孩子也不妨，那么根节点与孩子的连线，就没人看守，不符合题意。即：</p>
<p>他不见了。</p>
<p>如果当前节点没有孩子（叶节点），那么</p>
<p>他不见了。</p>
<p>，以及</p>
<p>他不见了。</p>
<p>。</p>
<p>【技巧】这一题，我们需要从叶节点倒推到根结点，那么，我们可以bfs，把节点bfs一边，再反过来遍历，不就是我们想要的顺序吗？不仅仅是这道题，很多有关树形的DP，都是这么解决顺序问题的。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Strategy_Game.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Strategy_Game.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000+10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; tree[maxn];</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; queue_;</span><br><span class="line"><span class="keyword">int</span> F[maxn][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp_i,k;</span><br><span class="line">        fin &gt;&gt; tmp_i &gt;&gt; k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=k; ++j) &#123;</span><br><span class="line">            <span class="keyword">int</span> x;</span><br><span class="line">            fin &gt;&gt; x;</span><br><span class="line">            tree[tmp_i].push_back(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> head=<span class="number">0</span>,tail=<span class="number">0</span>;</span><br><span class="line">    queue_.push_back(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (head&lt;=tail) &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp=queue_[head];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=tree[tmp].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            queue_.push_back(tree[tmp][i]);</span><br><span class="line"></span><br><span class="line">            tail++;</span><br><span class="line">        &#125;</span><br><span class="line">        head++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i*<span class="number">2</span>!=N; ++i)</span><br><span class="line">        swap(queue_[i],queue_[N-i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=N; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> root=queue_[i];<span class="comment">//当前节点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=tree[root].<span class="built_in">size</span>(); ++j) &#123;<span class="comment">//枚举孩子节点</span></span><br><span class="line">            <span class="keyword">int</span> children;</span><br><span class="line">            children=tree[root][j];</span><br><span class="line"></span><br><span class="line">            F[root][<span class="number">0</span>]+=F[children][<span class="number">1</span>];<span class="comment">//不放士兵的情况</span></span><br><span class="line">            F[root][<span class="number">1</span>]+=<span class="built_in">min</span>(F[children][<span class="number">0</span>],F[children][<span class="number">1</span>]);<span class="comment">//放士兵的情况</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tree[root].<span class="built_in">size</span>()!=<span class="number">0</span>)</span><br><span class="line">            F[root][<span class="number">1</span>]++;<span class="comment">//放了士兵，所以士兵数要加以1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tree[root].<span class="built_in">size</span>()==<span class="number">0</span>)&#123;<span class="comment">//叶节点的情况</span></span><br><span class="line">            F[root][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">            F[root][<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fout &lt;&lt; <span class="built_in">min</span>(F[<span class="number">0</span>][<span class="number">0</span>],F[<span class="number">0</span>][<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    in_();</span><br><span class="line"></span><br><span class="line">    bfs();<span class="comment">//bfs得出DP所需要的顺序</span></span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line"></span><br><span class="line">    out_();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>关于haywire的题解</title>
    <url>/Informatics%20In%20Junior/%E5%85%B3%E4%BA%8Ehaywire%E7%9A%84%E9%A2%98%E8%A7%A3/</url>
    <content><![CDATA[<p>【题目】有N头奶牛，还有N个房间。恰好，每一头奶牛都有3个好朋友，每对好朋友之间要铺电话线，电话线的长度就是他们房间的距离。问如何安排房间，使电话线长度最小。</p>
<p>【输入】</p>
<p>6</p>
<p>6 2 5</p>
<p>1 3 4</p>
<p>4 2 6</p>
<p>5 3 2</p>
<p>4 6 1</p>
<p>1 5 3</p>
<p>【输出】</p>
<p>17</p>
<p>【分析】首先，我们要意识到，这一题，我们用得是状态压缩的集合动态规划来完成。</p>
<p>那么，我们首先要看，如何定下状态呢？我们用集合s来表示当前状态（1表示已经入住房间，0表示尚未入住房间）。那么，我们枚举最后一个入住房间的奶牛p，如图：</p>
<p>他不见了。</p>
<p>现在，我们要看看，奶牛p入住后，会造成怎么样的变化？</p>
<p>如图：</p>
<p>他不见了。</p>
<p>假设奶牛p进入了集合s，为了给奶牛p一个位置，所有尚未入住的奶牛，都要左移一个单位。那么，入住的奶牛和未入住的奶牛的距离，就要加上一个单位。那么，枚举入住了的奶牛和未入住的奶牛，如果双方是朋友，那么增加的距离加1。</p>
<p>因此，状态转移方程就是</p>
<p>他不见了。</p>
<p>，而find_dist就是当前状态下，需要增加多长的电话线。注意的是，调用find_dist是，要默认p也在集合内，因为p自身也有朋友，也需要电话线。</p>
<p>然而，这一道题就是小问题改进大问题。</p>
<p>【程序】</p>
<p>```c++<br>#include <fstream><br>using namespace std;</p>
<p>ifstream fin(“haywire.in”);<br>ofstream fout(“haywire.out”);</p>
<p>#define maxn 15<br>#define oo 100000000</p>
<p>int F[1&lt;&lt;maxn];<br>int fri[maxn][3];<br>int N;</p>
<p>void in_() {<br>    fin &gt;&gt; N;<br>    for (int i=0; i&lt;=N; ++i) {<br>        int a, b, c;<br>        fin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</p>
<pre><code>    fri[i][0] = --a;
    fri[i][1] = --b;
    fri[i][2] = --c;//序号从0到N-1比较好处理
}</code></pre><p>}</p>
<p>int find_dist(int s) {<br>    int dist=0;<br>    for (int p=0; p!=N; ++p)//枚举p<br>        if (s &amp; (1&lt;&lt;p))//p要在集合内<br>            for (int i=0; i!=3; ++i) {<br>                int q=fri[p][i]; //枚举q<br>                if (!(s &amp; (1&lt;&lt;q))) //q要不在集合内<br>                    dist++;//增加的距离加1<br>          }</p>
<pre><code>return dist;</code></pre><p>}</p>
<p>void solve() {<br>    for (int i=0; i&lt;=(1&lt;&lt;N); i++)<br>        F[i] = oo;//全部初始化为正无穷</p>
<pre><code>F[0]=0;
for (int s=0; s!=(1&lt;&lt;N); s++)//枚举状态
    for (int p=0; p!=N; ++p) //枚举入住的奶牛
        if (!(s &amp; (1&lt;&lt;p))) {
            int tmp_s=s+(1&lt;&lt;p);

            F[tmp_s] &lt;?= F[s]+find_dist(tmp_s);//状态转移方程
        }</code></pre><p>}</p>
<p>void out_() {<br>    fout &lt;&lt; F[(1&lt;&lt;N)-1] &lt;&lt; endl;<br>}</p>
<p>int main() {<br>    in_();</p>
<pre><code>solve();//DP

out_();
return 0;</code></pre><p>}</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>关于topological sort（拓扑排序）的一点感悟</title>
    <url>/Informatics%20In%20Junior/%E5%85%B3%E4%BA%8Etopological%20sort%EF%BC%88%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%89%E7%9A%84%E4%B8%80%E7%82%B9%E6%84%9F%E6%82%9F/</url>
    <content><![CDATA[<p>拓扑排序，从某种意义上说，我们在小学的时候，就早早已经接触了。例如：现在有四个数，a，b，c，d，其中a&gt;c, a&gt;d, c&gt;d, d&gt;b,问从大到小排列着四个数。答案显然，就是a,c,d,b。这就是最简单的拓扑排序了。</p>
<p>【定义，理解】</p>
<p>事实上，一个有向无环图G[V,E]（简称DAG）,将其排成一个线性序列，使得所有边的方向都一致，这一过程就是拓扑排序。（粗略定义）</p>
<p>他不见了。</p>
<p>首先，我们一开头题目为例子。如图a所示，<br>我们大小关系用边的方向来表示（a&gt;d表示为a→d）。</p>
<p>我们移动点的位置，使得他们呈一条线排列，而且他们的边的方向都统一向右，显然，即如图b所示，</p>
<p>他不见了。</p>
<p>所以，排序后结果就是a,c,d,b。</p>
<p>【基本思路】</p>
<p>那么，我们应该如何让实现这一过程呢？</p>
<p>首先，我们多尝试几个例子，将其变成如图b的线性图后，发现：每个线性图的第一个点，入度都为0。证明：假设第一个点u的入读大于0，即有另外一个点s指向它，那么点s一定排在u前，与u是第一个点的条件矛盾，所以命题成立。</p>
<p>根据上述性质，我们只要找到入度为0的点v1（步骤1）。它就是拓扑排序后所得到的序列的第一个点v1。那么，如何让找到下一个点v2呢?</p>
<p>由于点v1的位置已经确定，无论它指向谁，都唔会对后面的序列产生影响，为了简便，我们将与v1相关联的边删去。不难发现，只要再重复上述步骤1，就可以得到点v2了。（步骤2）</p>
<p>综上所述，</p>
<p>① 找到入度为0的点vi，并加入序列尾部，执行步骤2；</p>
<p>② 删除与vi相关联的边，执行步骤3；</p>
<p>③ 若序列未满，则重复步骤1，否则退出。</p>
<p>【O(n*e)算法】</p>
<p>由于我们每次都要枚举每一个点，找到入度为0的点，然后搜索每一条边，若与之相关则删除，一共执行n次，故算法为O(n*e)。</p>
<p>程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//时间复杂度O(n^2) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 5005</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> A[maxn][maxn], n;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t!=n; ++t) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = find_();</span><br><span class="line">        num[r] = <span class="number">-1</span>;<span class="comment">//标记已经寻找过 </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, r);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j!=n; ++j)</span><br><span class="line">            <span class="keyword">if</span> (A[r][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                A[r][j] = <span class="number">0</span>;</span><br><span class="line">                num[j] --;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    freopen(<span class="string">"topological sort.in"</span>,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</span><br><span class="line">    freopen(<span class="string">"topological sort.out"</span>,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=m; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u=<span class="number">0</span>, s=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;u, &amp;s);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (A[s][u] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"No answer"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="comment">//判断环</span></span><br><span class="line">        <span class="keyword">if</span> (!(A[u][s] == <span class="number">1</span>)) &#123;</span><br><span class="line">            A[u][s] = <span class="number">1</span>;</span><br><span class="line">            num[s] ++;<span class="comment">//判断重边</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//读入，使用邻接矩阵储存，用数组（队列或优先队列）储存点的入度 </span></span><br><span class="line"></span><br><span class="line">    solve();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*fclose(stdin);</span></span><br><span class="line"><span class="comment">    fclose(stdout);*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【优化，O(n+e)算法】</p>
<p>由于我们知道，当我们确定某一个点vi时，需要删除与之相关的边，然后与之相关的点的入度都减1，那么下一个入度为0的点，一定是删除边前入度为1的点，即该点一定是与vi相邻的。因此，我们可以再搜索边时，寻找入度为0（删边后）的点，将其储存在队列中。那么在搜索入度为0的点时，直接用队列中的元素。（程序见附录）</p>
<p>在搜索边的方面，我们一般是判断每个点与vi是否相连，再进行下去，但会造成对于不必要的边的搜索。其实，我们用邻接表的方法，可以轻松解决这一问题（请教老师关于邻接表的实现方法）。</p>
<p>【应用】</p>
<p>拓扑排序应用极其广泛。特别是在工业生产方面，通过拓扑排序，我们可以得到每个生产任务的先后顺序，从而达到生产效率最大化的效果。</p>
<p>在数学方面，拓扑学这一数学学科，也在慢慢地展现其独特的魅力。</p>
<p>而在OI方面，拓扑排序可以将一个图转化成一条序列，在某些方面，会起到意想不到的效果</p>
<p>【附录】</p>
<p>Poj2367</p>
<p>2367 – Genealogical tree</p>
<p>其实本题就是一道裸题，注意输入输出即可。，</p>
<p>程序如下（有瑕疵，请帮助找错，谢谢）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 105</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A[maxn][maxn], n;</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">int</span> &gt; pos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">        <span class="keyword">if</span> (num[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            pos.push(i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t=<span class="number">0</span>; t!=n; ++t) &#123;</span><br><span class="line">        <span class="keyword">int</span> res=pos.front();</span><br><span class="line">        pos.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, res);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> u=<span class="number">1</span>; u&lt;=n; u++)</span><br><span class="line">            <span class="keyword">if</span> (A[res][u] == <span class="number">1</span> &amp;&amp; (--num[u]) == <span class="number">0</span>)&#123;</span><br><span class="line">                pos.push(u);</span><br><span class="line">                <span class="comment">//printf("*%d* ", u);</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; ;) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">            <span class="keyword">if</span> (x==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    A[i][x] = <span class="number">1</span>;</span><br><span class="line">                    num[x] ++;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    solve();</span><br><span class="line"></span><br><span class="line">    system(<span class="string">"pause"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>喜欢的，赞一个哦哦！！^–^</strong></p>
<p>Topological sort, to some extant, we have met it in primary school.For example, there are four numbers,a b c d, and a&gt;c ,a&gt;d,</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>创新班总结7.15</title>
    <url>/Informatics%20In%20Junior/%E5%88%9B%E6%96%B0%E7%8F%AD%E6%80%BB%E7%BB%937.15/</url>
    <content><![CDATA[<p>今天，我们迎来了夏令营的第一天，而老师，也为我们准备了许多丰富多彩的知识。</p>
<p>引入：现在桌子上有N颗小石子，我们假设每一颗小石子的价值都为1，那么我们现在可已将若干个小石子合并在一起，变成几堆石子。那么，我们应该如何分配，才可以使堆数最少，且可以表示1至N的价值（就是说，任意几堆可以加在一起表示一个价值）。</p>
<p>如图，是N=8的一种情况（其实也是最优）：</p>
<p>他不见了。</p>
<p>那么，价值1用堆1表示，价值2用堆2表示，价值3用堆1和堆2表示，依此类推。事实上，堆4只是多余的没有用途。</p>
<p>二进制：细心点我们可以发现，每一堆的个数都是1，2，4，8，16，……，2k-1，r（剩余的）。那么，这一分法就是题目所要求的吗？如何证明呢？</p>
<p>他不见了。</p>
<p>其实，把数字都看成二进制数，就容易多了。对于一颗长度在k位的二进制数，对于每一位来说，不论是0或是1，它都对应这一个2的幂数。如图括号所示。</p>
<p>那么，剩下的那个数r呢？假设前面按二进制分配好后和为S，那么S+1到S+r怎么表示呢？现在，我们已经可以表示1至S的每一个数了，那么，S+1至S+r的每一个数都减去一个r，必然在1至S之中，因此，配合上r这一堆，我们，就可以表示1至S+r的数了。要注意，对于按二进制分配好后，剩下的那个数r不要忘记了,它也算是一堆。</p>
<p>引入2：现在有一个天平，你可以控制k个砝码的重量，使得可以承重1至N的物品，如何分配。</p>
<p>当然，你可以用上面二进制的方法，但还有更好的方法吗？如图是一种称法：</p>
<p>他不见了。</p>
<p>说明天平可以两边同时放砝码。这范围又扩大了。</p>
<p>二进制不行，三进制可以吗？</p>
<p>三进制：当然可以。</p>
<p>他不见了。</p>
<p>首先，我们需要称量1克的物品，需要1克的砝码。</p>
<p>称量2克的物品，目前最多可以称量1克物品，那么我们需要一个砝码重G，使G-1=2，那么G=3，我们需要一个3克的砝码。</p>
<p>称量3克的物品，直接用3克的砝码。</p>
<p>称量4克的物品，用3克加上1克的砝码。</p>
<p>称量5克的砝码，目前最多可以称量4克物品，那么我们需要一个砝码重G，使G-4=5，那么G=9，我们需要一个9克的砝码。</p>
<p>……</p>
<p>那么，我们发现，砝码重量的变化是1，3，9，27，……，3k-1。其实，上面我们如此一条一条地举例归纳，是我们研究问题的一种重要的方法，那就是归纳法。</p>
<p>应用（部分背包问题O(nlog2n)）：01背包问题,完全背包问题，在此就不一一详谈了。</p>
<p>【题意】部分背包问题，就是有一个大小为load的背包，有N个物品，每一个物品有对应的体积w，价值v，数量t，们如何取舍，使放入背包的物品价值最高。</p>
<p>【以前思路】我们就在01背包的基础上，加多一层循环，枚举物品的数量，即把1个物品，2个物品，3个物品捆绑起来，达成一个新的物品，但是，缺点显而易见，时间复杂度O(n2)。</p>
<p>【二进制思路】由上可知，二进制的方法可以表示1-N的个数，却堆数最少（石子问题）。那么，我们就不需要把1个物品，2个物品，3个物品捆绑起来，只需把1个物品，2个物品，4个物品捆绑起来，这样，既可以表示一个物品的所有次数，而且，时间爱你复杂度也将到了O(nlog2n)。</p>
<p>注意, 按二进制捆绑好后，剩下的次数r不要忘记了。</p>
<p>【程序】</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Pack_part.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Pack_part.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxload 10000</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> w[maxn],v[maxn],t[maxn],n,load;</span><br><span class="line"><span class="keyword">int</span> F[maxload];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; n &gt;&gt; load;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        fin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; t[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> P=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;((P&lt;&lt;<span class="number">1</span>)&lt;t[i]);P&lt;&lt;=<span class="number">1</span>) <span class="comment">//P是控制当前捆绑的次数的，因此P每一次都乘以2</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=load; j&gt;=P*w[i]; --j)</span><br><span class="line">                F[j]=<span class="built_in">max</span>(F[j-P*w[i]]+P*v[i],F[j]);<span class="comment">//01背包的做法，只是重量，价值要乘上P</span></span><br><span class="line"></span><br><span class="line">        P=t[i]-(P&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (P==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=load; j&gt;=P*w[i]; --j)</span><br><span class="line">            F[j]=<span class="built_in">max</span>(F[j-P*w[i]]+P*v[i],F[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">-100000000</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=load; ++i)</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,F[i]);</span><br><span class="line">    </span><br><span class="line">    fout &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感想：二进制是以个神奇的东西，在很多方面都可以得到应用，特别是在时间复杂度方面，可以降至log2n，这是非常重要的。</p>
<p>而且，今后的学习可能会更加辛苦，需要我加倍的努力，因此，我应该发奋学习，学好总结，一分耕耘一分收获。</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>夏令营7.16总结</title>
    <url>/Informatics%20In%20Junior/%E5%A4%8F%E4%BB%A4%E8%90%A57.16%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天，我们主要是学习了两个方面的内容，分别是负二进制数，部分背包问题的补充（可见另一篇文章），最长公共子序列，以及有关调试方面的经验。</p>
<p>最长公共子序列：昨天学习了部分背包分体，就意味着我们已经进入到动态规划的学习当中了。</p>
<p>【题目】给定A，B两个字符串，若字符串C既是A的子序列，有时B的子序列，那么C最长为多少？（当A（Ｂ）去掉某一些字符，变成另一个字符串Ｃ，那么Ｃ就是Ａ（Ｂ）的子序列）</p>
<p>【输入】</p>
<p>ａｂｘｙｃｚ</p>
<p>ｘａｂｙｃｚ</p>
<p>【输出】</p>
<p>５</p>
<p>（ａｂｙｃｚ）</p>
<p>【思路１】假如我们先在采用寻找子问题的方式，来解决这一个问题。如图，首先我们定位在Ａ串的第一个字母ａ，这一个字母是可选可不选。若果不选，那么任务就变成了，求红色框内的最长公共子序列。那么如果是选，那就要寻找与它（ａ）相匹配的字母（位置必须大于等于它（ａ）的位置，且是离它（ａ）最近），那么任务就变成了，求蓝色框内的最长公共子序列。由于每一个字母都要找与之相匹配的字母，所以最好要预处理。</p>
<p>他不见了。</p>
<p>但是，如果这么办，明显不符和我们的思维常理（虽然这是可行的），这需要从后面向前推，很麻烦。其实，我们换个方向，道理还是一样的。如图：</p>
<p>他不见了。</p>
<p>【思路２】思路１的方法固然简单，单边起来较复杂，这就在于它要预处理，字母与字母的匹配问题，非常麻烦。</p>
<p>其实，我们可以用数组F[i][j]来表示A串1-i，B串1-j的最长公共子序列。如图，现在i=4(a[i]=’y’)，j=3(b[j]=’b’)，现在a[i]≠a[j]，那么如思路一一样，子问题就成了红色框的（以’b’来说），以及蓝色框的（以’a’来说），即F[i-1][j]，F[i][j-1]。</p>
<p>他不见了。</p>
<p>如果两个字母相等的话，除了上面几种情况以外，还有一种情况，那就是都被选上了，即F[i-1][j-1]+1的情况（如图黄色区域）。</p>
<p>他不见了。</p>
<p>总的来说，就是</p>
<p>【表格法】细心的同学不知有没有发现，这有点像表格，如图，蓝色的格子等于上一格，左边那一格的最大值，，而红色的格子等于上边，左边，坐上边+1的最大值。</p>
<p>他不见了。</p>
<p>程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"longest common subsequence.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"longest common subsequence.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> x,y;</span><br><span class="line"><span class="keyword">int</span> F[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; x;</span><br><span class="line">    fin &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">    x=<span class="string">'#'</span>+x;</span><br><span class="line">    y=<span class="string">'$'</span>+y;<span class="comment">//再接下来的动态规划是，F[0]是边界，若字符串再以下标0为起点，会有所不便</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i!=x.<span class="built_in">size</span>(); i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j!=y.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            F[i][j]=<span class="built_in">max</span>(F[i<span class="number">-1</span>][j],F[i][j<span class="number">-1</span>]);<span class="comment">//这是不相等的情况下</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x[i]==y[j]) F[i][j]=<span class="built_in">max</span>(F[i][j],F[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>); <span class="comment">//这是相等的情况下</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; F[x.<span class="built_in">size</span>()<span class="number">-1</span>][y.<span class="built_in">size</span>()<span class="number">-1</span>];<span class="comment">//别忘了要减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调试：调试，是我每次编程最为头痛的事了，仅次于算法分析，但是，老师讲了调试的有关经验后，让我收益匪浅。</p>
<p>首先，编程技巧可以减少调试的用时，主要有一下几种：</p>
<p>① 二分查找定位错误点</p>
<p>② 静态查错是很重要的方法</p>
<p>③ 用文件输入输出</p>
<p>④ 调试时的盲点</p>
<ol>
<li><p>读入(偶尔有输出)数据时的错误。</p>
</li>
<li><p>“复制+粘贴”的错误。</p>
</li>
<li><p>下标变量出错。</p>
</li>
</ol>
<p>而调试时，最有效的，就是打印中间信息法。其中，这也有几点技巧：</p>
<p>① 调试语句的位置最好明显一些，以便事后关闭。</p>
<p>② 打印一些相关的数据，给出适当的提示信息，可以比较清楚地查看信息。</p>
<p>③ 在输出前面应用一些if()条件，可以更加有选择性地输出特定的信息，做到精确调试。</p>
<p>④ 善于使用自己的调试函数。</p>
<p>⑤ 阅读XXX.out文件可以在集成中的多窗口中（如：freepascal或dev-cpp等），也可单独的notpad中。</p>
<p>⑥ 提交程序要注意“关闭”调试信息。</p>
<p>当然，最有效的，当然是用GDB了。在此，我就不在这详谈。</p>
<p>【感受】这两天，学习了不少内容，空闲时间需要好好消化一下，可以尝试坐一坐相关的题目（最好由易至难），这样，就更有效率了。</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>夏令营7.17总结</title>
    <url>/Informatics%20In%20Junior/%E5%A4%8F%E4%BB%A4%E8%90%A57.17%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>今天早上，我们不仅对昨天的最长公共子序列，有一些扩展，而且，还讲了线段性动态规划（石子归并）。</p>
<p>线段性动态规划（石子归并）：</p>
<p>【题目】地上有N堆石子，每堆石子都有重量G[i]。现在，你可以将任意相邻的两堆石子i，j，合并成一堆，那么所花费的代价是G[i]+G[j]，如此类推，知道只剩下一堆。问，代价最小是多少。</p>
<p>【输入】</p>
<p>【输出】</p>
<p>61</p>
<p>【理解题意】其实，题目意思就是，一串数字，每相邻的两个数可以相加，变成一个新的数，而结果要加上，这两个数之和。如图，这是一种分法。那么， 11+6+15+18+24=74。</p>
<p>他不见了。</p>
<p>下图也是一种分法（答案），代价为7+6+13+11+24=61。</p>
<p>他不见了。</p>
<p>【贪心（错误）】有人说，这题可以用贪心做，只要不断的把，相邻的，和最小的两个数合并，不就行了吗？</p>
<p>是吗？举出反例是最好的反驳。加入数据为[6,5,5,6]，若按贪心做，则为[6,5,5,6]，[6,10,6]，[16,6]，[22]，代价为48，而正解为[6,5,5,6][11,5,6][11,11][22]，代价为44。因此，贪心是不可行的。</p>
<p>【子问题】如果这一题用搜索，我们应该怎么做呢？当然是找子问题。我们知道，无论如何，合并成最后一堆的重量，一定是石子重量之和。如同样例，最后一堆，必定为24。那么，我们用反向思维来看，最后一堆终究是两堆石子合并成的，那么我们枚举它们最后一堆的合并位置，分成左右两堆的子问题，不就行了吗？</p>
<p>如图, [3,4,6,5,4,2]就可以分成[3,4,6,5]和[4,2]两个子问题，[3,4,6,5]的代价加上[4,2]的代价加上22，就是一种可能。再加上记忆化搜索，就可以实现了。</p>
<p>他不见了。</p>
<p>【动态规划】搜索虽然可行，但是也有弊端，就是容易爆栈，而且不容易表示，分了又分，难以表示。但是，子问题同样适用于动态规划，可以用动态规划解决。但是，难点又来了，怎么分阶段呢？</p>
<p>这是一个新知识点：以长度分阶段。我们可以用数组F[i][j]表示以i为起点，以j为终点，石子合并的最小代价。</p>
<p>当长度为1的时候，就是所有的石子都不用合并，所以，每一颗石子的代价为0，即F[i][j]=0（i=j）。</p>
<p>当长度为2的时候，[3,4]只有一个合并点，就是[3][4]之间，那么，[3,4]合并起来的代价就是，合并[3]的代价加上，合并[4]的代价，加上[3,4]的总重，即F[1][2]=F[1,1]+F[2][2]+G[i]+G[j];依此类推。</p>
<p>当长度为3的时候，如[3,4,5]，有两个合并点，那么我们可以枚举合并点，一种可能是[3][4,5]那么代价为F[1][3]=F[1,1]+F[2,3]+G[1]+G[2]+G[3]，还有一种可能，就是[3,4][5]，代价为F[1][3]=F[1,2]+F[3,3]+G[1]+G[2]+G[3]。因此，我们要取所有可能的最小代价，那么结果才会最优。</p>
<p>注意到上面的下划线部分，这些都是相同的，因此，我们可以用预处理地方法，把第i到第j堆的重量算出来，以便于计算。</p>
<p>……</p>
<p>7  10  11  9  6</p>
<p>20  25  24  17</p>
<p>36  38  34</p>
<p>51  48</p>
<p>61</p>
<p>做完长度为N的DP时，就结束了。输出，F[i][j]。</p>
<p>因为这是从第i个到第j个的最优质，从数轴上看，这就像一条线段，因此，这种动态规划，叫做线段性动态规划；</p>
<p>程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"storm_merge.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"storm_merge.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 80</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> storm[maxn],n;</span><br><span class="line"><span class="keyword">int</span> cnt[maxn][maxn],F[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        fin &gt;&gt; storm[i];<span class="comment">//读入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j!=n; ++j)</span><br><span class="line">            cnt[i][j]=cnt[i][j<span class="number">-1</span>]+storm[j];<span class="comment">//预处理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p&lt;=maxn; ++p)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> q=<span class="number">0</span>; q&lt;=maxn; ++q)</span><br><span class="line">            F[p][q]=<span class="number">100000000</span>;<span class="comment">//要求最小，所以所有的到家初始化为正无穷</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> p=<span class="number">0</span>; p!=n; ++p)</span><br><span class="line">        F[p][p]=<span class="number">0</span>;<span class="comment">//当i=j时，F[i][j]为0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len=<span class="number">2</span>; len&lt;=n; ++len)<span class="comment">//以长度划分阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l=<span class="number">0</span>; l&lt;=n-len; ++l) &#123;<span class="comment">//枚举左端点</span></span><br><span class="line">            <span class="keyword">int</span> r=l+len<span class="number">-1</span>;<span class="comment">//从而确定右端点</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> mid=l; mid!=r; ++mid) &#123;<span class="comment">//枚举合并点</span></span><br><span class="line">                F[l][r]=<span class="built_in">min</span>(F[l][r],F[l][mid]+F[mid+<span class="number">1</span>][r]+cnt[l][r]);<span class="comment">//DP状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; F[<span class="number">0</span>][n<span class="number">-1</span>] &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>【感受】第一次接触线段性动态规划，这是一个难点，也是重点。但是，我一定能够熟练掌握的。</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>A4解题报告</title>
    <url>/Informatics%20In%20Junior/A4%E8%A7%A3%E9%A2%98%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<p>字符串加密（jiami）</p>
<p>【问题描述】TOM找到了一份为一些文件的某些部分加密的工作，加密的部分是一串小写英文字母，加密的规则是这样的：要是连续出现相同的字母，则把他们替换成这个字母的大写形式，后面紧跟相同字母的个数，并把它之前跟之后的两段字串调换，例如出现bcaaaaaaef则新字符串变成：efA6bc。然后从新扫描字串，直到没有出现相同小写字母为止。</p>
<p>【输入格式】<br>文件只有一行数据：原始字符串。</p>
<p>【输出格式】<br>文件只有一行数据：新字符串。</p>
<p>【输入样例1】<br>bcaaaaaaef</p>
<p>【输出样例1】<br>efA6bc</p>
<p>【输入样例2】<br>cmmmcefffg</p>
<p>【输出样例2】<br>gM3cF3ce</p>
<h2 id="2011-12-27-星期六"><a href="#2011-12-27-星期六" class="headerlink" title="2011-12-27 星期六"></a>2011-12-27 星期六</h2><p>前不久，做了字符串第四题，说实在的，挺难的，做了我差不多三节课呢！</p>
<p>初看，不太懂，再看，原来就三个内容：</p>
<ol>
<li><p>要是连续出现相同的字母，则把他们替换成这个字母的大写形式，后面紧跟相同字母的个数；</p>
</li>
<li><p>并把它之前跟之后的两段字串调换；</p>
</li>
<li><p>然后从新扫描字串，直到没有出现相同小写字母为止。</p>
</li>
</ol>
<p>那么我就想到了用两个过程和一个函数进行实现，如下：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">zmbsz</span><span class="params">(ch:char; <span class="keyword">var</span> mun:integer)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    wz:integer;</span><br><span class="line">    stt:<span class="keyword">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    wz:=pos(ch,st);</span><br><span class="line">    st[wz]:=upcase(ch);</span><br><span class="line">    str(mun,stt);</span><br><span class="line">    insert(stt,st,wz+<span class="number">1</span>);</span><br><span class="line">    delete(st,wz+length(stt)+<span class="number">1</span>,mun-<span class="number">1</span>);</span><br><span class="line">    mun:=length(stt)+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;<span class="comment">//NO.1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">procedure</span> <span class="title">jh</span><span class="params">(q,h:<span class="keyword">string</span>)</span>;</span></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    newst:<span class="keyword">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    newst:=h+copy(st,pp,mun)+q;</span><br><span class="line">    st:=newst;</span><br><span class="line"><span class="keyword">end</span>;<span class="comment">//NO.2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pd</span><span class="params">(str:<span class="keyword">string</span>)</span>:</span>boolean;</span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">    i,j:integer;</span><br><span class="line">    yes:boolean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    yes:=true;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> length(str)-<span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">for</span> j:=i+<span class="number">1</span> <span class="keyword">to</span> length(str) <span class="keyword">do</span></span><br><span class="line">        <span class="comment">// 原来是没有的，后来发现是检查是否有相同连续小写字母，把连续给忘了。</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (st[i]=st[j]) <span class="keyword">and</span> ((st[i]&gt;=<span class="string">'a'</span>) <span class="keyword">and</span> (st[i]&lt;=<span class="string">'z'</span>)) <span class="keyword">and</span> ((st[j]&gt;=<span class="string">'a'</span>) <span class="keyword">and</span> (st[j]&lt;=<span class="string">'z'</span>)) <span class="keyword">and</span> (st[j]=st[i+<span class="number">1</span>]) <span class="keyword">then</span> yes:=false;</span><br><span class="line">    </span><br><span class="line">    pd:=yes;</span><br><span class="line"><span class="keyword">end</span>;<span class="comment">//NO.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一开始，也不知道咋的，老是出现死循环，一看，原来是检查字符串时，if语句出现错误，看！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接着就是主程序的问题了，运行时竟然有错！</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    readln(st);</span><br><span class="line">    <span class="keyword">repeat</span></span><br><span class="line">        ing:=false;</span><br><span class="line">        mun:=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> length(st) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">        <span class="comment">// 记得是在找连续字母时出错的。</span></span><br><span class="line">            <span class="keyword">if</span> st[i]=st[i+<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span>(ing) <span class="keyword">then</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                <span class="comment">// 分了两个内容，一个是找到开头的第一个字母，二是找连续的数目。</span></span><br><span class="line">                    ing:=true;</span><br><span class="line">                    pp:=i;</span><br><span class="line">                    <span class="comment">//这是连续字母结束时做的：</span></span><br><span class="line">                    mun:=<span class="number">2</span>;</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">else</span> mun:=mun+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ing <span class="keyword">and</span> <span class="keyword">not</span>(st[i]=st[i+<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                zmbsz(st[pp],mun);</span><br><span class="line">                jh(copy(st,<span class="number">1</span>,pp-<span class="number">1</span>),copy(st,pp+mun,length(st)-length(copy(st,<span class="number">1</span>,pp-<span class="number">1</span>))-mun));</span><br><span class="line"> </span><br><span class="line"><span class="comment">(*问题主要在这里：</span></span><br><span class="line"><span class="comment">1. 一大串函数，看得烦人，容易出错。</span></span><br><span class="line"><span class="comment">2. 再提取中间时，（棕色的），似乎少加了个括号，以及逻辑不清晰，pp和mun的关系没弄好。*)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">until</span> pd(st);</span><br><span class="line"></span><br><span class="line">    writeln(st);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>

<p>终于好了，我也高兴了。</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux/Change-Repository-Sourse</title>
    <url>/Linux/Change-Repository-Sourse/</url>
    <content><![CDATA[<p>After you install some common softwares or programmers, usually the first thing you need to do is to change the source addresses of softwares or package managers for chinese users. Here are some common tutorials.</p>
<a id="more"></a>

<h2 id="Change-Apt-get-Repository-Source"><a href="#Change-Apt-get-Repository-Source" class="headerlink" title="Change Apt-get Repository Source"></a>Change Apt-get Repository Source</h2><h3 id="ubuntu20-04-LTS"><a href="#ubuntu20-04-LTS" class="headerlink" title="ubuntu20.04 LTS"></a>ubuntu20.04 LTS</h3><p>We take the ubuntu20.04 LTS as an example.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak <span class="comment"># backup (optional)</span></span><br><span class="line">sudo vi /etc/apt/sources.list <span class="comment"># edit the source list file</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># file: /etc/apt/sources.list</span></span><br><span class="line"><span class="comment"># comment out the original content and add the content below (Tsinghua University source)</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line"></span><br><span class="line">sudo apt-get update <span class="comment"># update list</span></span><br></pre></td></tr></table></figure>

<p><strong><em>Attention</em></strong>:</p>
<ol>
<li><p>“deb” source address corresponds to the command <code>apt</code>, which will only get the binary files without compiling, and “deb-src” source address corresponds to the command <code>apt-get</code>, which may get the source codes and compile them. </p>
</li>
<li><p>the format of source address is</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://site.example.com/debian distribution component1 component2 component3</span><br><span class="line">deb-src http://site.example.com/debian distribution component1 component2 component3</span><br></pre></td></tr></table></figure>
<p> where the “distribution” is usually “ubuntuCodeName-sourceBranch”.</p>
<p> ubuntuCodeName is related to the version of ubuntu system and can be found by the command <code>lsb_release -a</code>. Here are some ubuntu alias name:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">14.04 LTS ----&gt; Trusty</span><br><span class="line">16.04 LTS ----&gt; Xenial</span><br><span class="line">18.04 LTS ----&gt; Bionic</span><br><span class="line">20.04 LTS ----&gt; Focal</span><br></pre></td></tr></table></figure>

<p> sourceBranch is usually *”empty”*/security/updates/backports/proposed. Proposed branch is pre-release software source, which is not recommended to use.</p>
<p> component is usually main/restricted/universe/multiverse</p>
<p> <strong><em>If your system is not ubuntu20.04 LTS, you need to replace the source address by yourself.</em></strong></p>
</li>
</ol>
<p>Here are some famous repository source addresses (ubuntu20.04 LTS):</p>
<details>
<summary>Address</summary>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Tsinghua University</span></span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># University of Science and Technologyof China</span></span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src https://mirrors.ustc.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Ali Cloud</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure>
</details>

<h3 id="Respberry-Pi"><a href="#Respberry-Pi" class="headerlink" title="Respberry Pi"></a>Respberry Pi</h3><p>The first thing you need to do is finding the code name of your respbian system version by command <code>lsb_release -a</code></p>
<p>Take an example whose code name is <strong>“bullseye”</strong>(Respberry Pi 4b):</p>
<p>Comment the original content and additional content you need to add in <code>/etc/apt/sources.list</code> file:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi</span><br><span class="line">deb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ bullseye main non-free contrib rpi</span><br></pre></td></tr></table></figure>

<p>And in <code>/etc/apt/sources.list.d/raspi.list</code> file, you need to comment the original content as well and add:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ bullseye main ui</span><br></pre></td></tr></table></figure>

<p>If your system has another code name, just replace the code name part of the address and do the same thing.</p>
<p>Don’t forget to execute <code>sudo apt-get update</code></p>
<h2 id="Change-Pip-Repository-Source"><a href="#Change-Pip-Repository-Source" class="headerlink" title="Change Pip Repository Source"></a>Change Pip Repository Source</h2><p>Assuming you have successfully install <strong>Python3</strong> and <strong>Pip</strong> package manager, do the following steps.</p>
<p>Temporary Use:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple <span class="comment"># use -i parameter</span></span><br></pre></td></tr></table></figure>

<p>Permanent Use:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip config <span class="built_in">set</span> global.index-url https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></table></figure>

<p>Here are some famous pip source addresses: </p>
<details>
<summary>Address</summary>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://pypi.tuna.tsinghua.edu.cn/simple/ <span class="comment"># Tsinghua University</span></span><br><span class="line">https://pypi.mirrors.ustc.edu.cn/simple/ <span class="comment"># University of Science and Technologyof China</span></span><br><span class="line">http://mirrors.aliyun.com/pypi/simple/ <span class="comment"># Ali Cloud</span></span><br><span class="line">http://mirrors.myhuaweicloud.com/pypi/web/simple <span class="comment"># Huwwei Cloud</span></span><br></pre></td></tr></table></figure>
</details>

<h2 id="Change-Docker-Reposition-Address"><a href="#Change-Docker-Reposition-Address" class="headerlink" title="Change Docker Reposition Address"></a>Change Docker Reposition Address</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># add the following content in daemon.json file</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="string">"registry-mirrors"</span>: [<span class="string">"https://registry.docker-cn.com"</span>]</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">sudo service docker restart <span class="comment"># restart docker</span></span><br></pre></td></tr></table></figure>

<p>Here are some famous docker mirror reposition addresses: </p>
<details>
<summary>Address</summary>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://registry.docker-cn.com <span class="comment"># Docker china official address</span></span><br><span class="line">https://kfwkfulq.mirror.aliyuncs.com <span class="comment"># Ali Cloud</span></span><br></pre></td></tr></table></figure>
</details>

<h2 id="Change-Homebrew-Reposition-Address-MacOS"><a href="#Change-Homebrew-Reposition-Address-MacOS" class="headerlink" title="Change Homebrew Reposition Address (MacOS)"></a>Change Homebrew Reposition Address (MacOS)</h2><h4 id="If-you-have’n-install-Homebrew"><a href="#If-you-have’n-install-Homebrew" class="headerlink" title="If you have’n install Homebrew"></a>If you have’n install Homebrew</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HOMEBREW_BREW_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git"</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_CORE_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git"</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles"</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">clone</span> --depth=1 https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/install.git brew-install</span><br><span class="line">/bin/bash brew-install/install.sh</span><br><span class="line">rm -rf brew-install</span><br></pre></td></tr></table></figure>

<p>Then add environment path to <code>~/.zprofile</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.zprofile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BREW_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git"</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_CORE_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git"</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles"</span></span><br></pre></td></tr></table></figure>

<p>If you use <strong>arm64 MacOS</strong> ,some extra steps are needed. Intel macOS doesn’t need it.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">test</span> -r ~/.zprofile &amp;&amp; <span class="built_in">echo</span> <span class="string">'eval "$(/opt/homebrew/bin/brew shellenv)"'</span> &gt;&gt; ~/.zprofile</span><br></pre></td></tr></table></figure>

<h4 id="If-you-have-install-homebrew"><a href="#If-you-have-install-homebrew" class="headerlink" title="If you have install homebrew"></a>If you have install homebrew</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> HOMEBREW_BREW_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git"</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_CORE_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git"</span></span><br><span class="line">brew tap --custom-remote --force-auto-update homebrew/core https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line">brew tap --custom-remote --force-auto-update homebrew/cask https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git</span><br><span class="line">brew tap --custom-remote --force-auto-update homebrew/cask-fonts https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-fonts.git</span><br><span class="line">brew tap --custom-remote --force-auto-update homebrew/cask-drivers https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-drivers.git</span><br><span class="line">brew tap --custom-remote --force-auto-update homebrew/cask-versions https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask-versions.git</span><br><span class="line">brew tap --custom-remote --force-auto-update homebrew/<span class="built_in">command</span>-not-found https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-command-not-found.git</span><br><span class="line"></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>Or use script here,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BREW_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git"</span></span><br><span class="line">brew update</span><br><span class="line"><span class="built_in">export</span> HOMEBREW_CORE_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git"</span></span><br><span class="line"><span class="keyword">for</span> tap <span class="keyword">in</span> core cask&#123;,-fonts,-drivers,-versions&#125; <span class="built_in">command</span>-not-found; <span class="keyword">do</span></span><br><span class="line">    brew tap --custom-remote --force-auto-update <span class="string">"homebrew/<span class="variable">$&#123;tap&#125;</span>"</span> <span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-<span class="variable">$&#123;tap&#125;</span>.git"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>

<p>Adding environment paths to <code>~/.zprofile</code> is recommended.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.zprofile</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BREW_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git"</span></span><br><span class="line">brew update</span><br><span class="line"><span class="built_in">export</span> HOMEBREW_CORE_GIT_REMOTE=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git"</span></span><br></pre></td></tr></table></figure>

<h4 id="Restore-offical-reposition-assdress"><a href="#Restore-offical-reposition-assdress" class="headerlink" title="Restore offical reposition assdress"></a>Restore offical reposition assdress</h4><p>Use the script here,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">unset</span> HOMEBREW_BREW_GIT_REMOTE</span><br><span class="line">git -C <span class="string">"<span class="variable">$(brew --repo)</span>"</span> remote <span class="built_in">set</span>-url origin https://github.com/Homebrew/brew</span><br><span class="line"></span><br><span class="line"><span class="built_in">unset</span> HOMEBREW_CORE_GIT_REMOTE</span><br><span class="line">BREW_TAPS=<span class="string">"<span class="variable">$(BREW_TAPS="$(brew tap 2&gt;/dev/null)</span>"</span>; <span class="built_in">echo</span> -n <span class="string">"<span class="variable">$&#123;BREW_TAPS//$'\n'/:&#125;</span>"</span>)<span class="string">"</span></span><br><span class="line"><span class="string">for tap in core cask&#123;,-fonts,-drivers,-versions&#125; command-not-found; do</span></span><br><span class="line"><span class="string">    if [[ "</span>:<span class="variable">$&#123;BREW_TAPS&#125;</span>:<span class="string">" == *"</span>:homebrew/<span class="variable">$&#123;tap&#125;</span>:<span class="string">"* ]]; then  # 只复原已安装的 Tap</span></span><br><span class="line"><span class="string">        brew tap --custom-remote "</span>homebrew/<span class="variable">$&#123;tap&#125;</span><span class="string">" "</span>https://github.com/Homebrew/homebrew-<span class="variable">$&#123;tap&#125;</span><span class="string">"</span></span><br><span class="line"><span class="string">    fi</span></span><br><span class="line"><span class="string">done</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">brew update</span></span><br></pre></td></tr></table></figure>

<h4 id="Homebrew-binary-precompile-images"><a href="#Homebrew-binary-precompile-images" class="headerlink" title="Homebrew binary precompile images"></a>Homebrew binary precompile images</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi ~/.</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> HOMEBREW_BOTTLE_DOMAIN=<span class="string">"https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles"</span></span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>石门中学2012创新班03</title>
    <url>/Informatics%20In%20Junior/%E7%9F%B3%E9%97%A8%E4%B8%AD%E5%AD%A62012%E5%88%9B%E6%96%B0%E7%8F%AD03/</url>
    <content><![CDATA[<p>这是我来创新班的第一节课，只要是学习c++，尽管这只是一个语言，但是，我依然受益匪浅。</p>
<p>今天只要学习的是c++的基本入门，主要是以下几点：</p>
<ol>
<li>运算表达式。其中有条件运算，算术运算。而算术运算的关系如下图：</li>
</ol>
<p>他消失了。</p>
<p>其重要注意的是等于是“==”；不等于是“！=”，以及非是“!”,这与pascal是不同的。</p>
<p>算术运算，就是+-*/等等，但是，求余的是“%”，而若两边除数都是整型，那么“/”就是整除；只要其中一边是实型，那么“/”就是直接除。<br>还有就是优先级，与pascal差不多……</p>
<ol start="2">
<li>关于if条件语句。if结构是</li>
</ol>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件)</span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  语句1；</span></span><br><span class="line"><span class="comment">  语句2；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">&#123; </span></span><br><span class="line"><span class="comment">  语句1；</span></span><br><span class="line"><span class="comment">  语句2；</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>

<p>注意的是，if后的括号一定要加上。否则出错，其余与pascal类似。</p>
<ol start="3">
<li>关于for循环。for循环结构在c++是“for (int i;i&lt;=n;i++)”，其中，i是循环变量，可以直接定义。</li>
</ol>
<p>特别注意的是，变量定义只对以下行有效，而且，定义还是细分到语句，而不同于pascal的局部变量；</p>
<p>回到for循环，若i满足于“i&lt;=n”，那么就继续循环，注意，第二个参数位置是布尔型。</p>
<p>第三个参数的位置，是每循环一次就执行一次的语句。如上，就是i每次加1（i++就是i=i+1）.</p>
]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>车厢重组carry</title>
    <url>/Informatics%20In%20Junior/%E8%BD%A6%E5%8E%A2%E9%87%8D%E7%BB%84carry/</url>
    <content><![CDATA[<p>[问题描述]：</p>
<p>在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转180度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。</p>
<p>[输入]：</p>
<p>输入文件有两行数据，第一行是车厢总数N（不大于10000），第二行是N个不同的数表示初始的车厢顺序。</p>
<h2 id="2012-1-17-星期二"><a href="#2012-1-17-星期二" class="headerlink" title="2012-1-17 星期二"></a>2012-1-17 星期二</h2><p>初看这题，还有点像冒泡排序，因为这就是不断交换排列；但又有点不同，这是因为这一题只能相邻的两个数进行交换。刚想时想用集合进行控制，但无奈，集合不分先后顺序，只能用数组。</p>
<p>很快，我就想出了一个思路。简单说：<strong>①就是找一个最大数，把它与相邻的数进行交换，直到到了数组最后一个，然后排除掉（并不是删掉，之手漠视他，可以用一个变量，控制数组长度）再重复一步骤，直到排序完毕（即控制数组长度变量为0）</strong>。</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line">A.  找最大数</span><br><span class="line">B.  <span class="keyword">For</span> i:=最大数的位置+<span class="number">1</span> <span class="keyword">to</span> la(控制数组长度变量) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">Begin</span> inc(time(次数变量)); 交换a[i]与a[i-<span class="number">1</span>] <span class="keyword">end</span>;</span><br><span class="line">    La:=la-<span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>程序如下：</p>
<figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span></span><br><span class="line">    a:<span class="keyword">array</span>[<span class="number">1</span>..<span class="number">10000</span>] <span class="keyword">of</span> integer;</span><br><span class="line">    n,la,time,i,max:longint;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    readln(n);</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> n <span class="keyword">do</span> <span class="keyword">read</span>(a[i]);<span class="comment">//输入</span></span><br><span class="line"></span><br><span class="line">    la:=n;</span><br><span class="line">    <span class="keyword">while</span> la&gt;<span class="number">0</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        max:=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">1</span> <span class="keyword">to</span> la <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">if</span> a[i]&gt;=a[max] <span class="keyword">then</span> max:=i;<span class="comment">//找最大数</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i:=max+<span class="number">1</span> <span class="keyword">to</span> la <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            inc(time);</span><br><span class="line">            a[i]:=a[i]+a[i-<span class="number">1</span>];</span><br><span class="line">            a[i-<span class="number">1</span>]:=a[i]-a[i-<span class="number">1</span>];</span><br><span class="line">            a[i]:=a[i]-a[i-<span class="number">1</span>];<span class="comment">//交换</span></span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">        la:=la-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line">    writeln(time);</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Essay</tag>
      </tags>
  </entry>
  <entry>
    <title>Phase Transition and Critical Phenomenon Note</title>
    <url>/Physics/Phase-Transition-and-Critical-Phenomenon-Note/</url>
    <content><![CDATA[<p>The Note is written by Chinese.</p>
<a id="more"></a>

<center>

<p><a href="./1.pdf">Download Here!</a></p>
</center>

]]></content>
      <categories>
        <category>Physics</category>
      </categories>
      <tags>
        <tag>Physics</tag>
        <tag>Phase Transition</tag>
        <tag>Statistical Mechanics</tag>
      </tags>
  </entry>
  <entry>
    <title>部分背包问题的补充</title>
    <url>/Informatics%20In%20Junior/%E9%83%A8%E5%88%86%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A1%A5%E5%85%85/</url>
    <content><![CDATA[<p>关于部分背包问题，之前我们已经阐述了O(nlog2n)的算法。但是我们要注意，这是建立在背包不一定需要装满的情况下，若是背包一定需要恰好装满，那么会怎么样呢？两者之间有什么不同呢？</p>
<p>这有着本质上的不同。</p>
<p>部分背包：f[i] 两种要求（不同题目）：</p>
<p>重量&lt;=i的最优值</p>
<p>重量==i的最优值</p>
<p>如图（若物品大小，价值均为5）：</p>
<p>他不见了。</p>
<p>事实上，对于每一格,存放的是当前容量,可放置的最大价值.若是存放当前容量,恰好放置的最大价值。如图：</p>
<p>他不见了。</p>
<p>假设我们每一个都初始化为-1，充当着哨兵，表示没有存放任何东西（第0位要改为0，因为接下来才可以放东西）。背包DP时，我们i从总容量load-w扫描0（倒着），判断当前的容量是否为-1，不是，那么F[i+w]才可以进行状态转移。</p>
<p>程序如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ifstream <span class="title">fin</span><span class="params">(<span class="string">"Pack_part_fill-up.in"</span>)</span></span>;</span><br><span class="line"><span class="function">ofstream <span class="title">fout</span><span class="params">(<span class="string">"Pack_part_fill-up.out"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> maxload 10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> w[maxn],v[maxn],t[maxn],n,load;</span><br><span class="line"><span class="keyword">int</span> F[maxload];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fin &gt;&gt; n &gt;&gt; load;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i)</span><br><span class="line">        fin &gt;&gt; w[i] &gt;&gt; v[i] &gt;&gt; t[i];<span class="comment">//读入</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(F,<span class="number">-1</span>,<span class="keyword">sizeof</span>(F));<span class="comment">//整个数组清为-1</span></span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//但是第0位要为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i!=n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> P=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (;((P&lt;&lt;<span class="number">1</span>)&lt;=t[i]);P&lt;&lt;=<span class="number">1</span>) <span class="comment">//二进制捆绑</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=load-P*w[i]; j&gt;=<span class="number">0</span>; --j)<span class="comment">//倒着的</span></span><br><span class="line">                <span class="keyword">if</span> (F[j]!=<span class="number">-1</span>)<span class="comment">//当前容量不为-1才行</span></span><br><span class="line">                    F[j+P*w[i]]=<span class="built_in">max</span>(F[j]+P*v[i],F[j+P*w[i]]);</span><br><span class="line">                   </span><br><span class="line">        P=t[i]-(P&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (P==<span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=load-P*w[i]; j&gt;=<span class="number">0</span>; --j)</span><br><span class="line">            <span class="keyword">if</span> (F[j]!=<span class="number">-1</span>)</span><br><span class="line">                F[j+P*w[i]]=<span class="built_in">max</span>(F[j]+P*v[i],F[j+P*w[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fout &lt;&lt; F[load];<span class="comment">//最后直接输出F[load]，不用找最大了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Informatics In Junior</category>
      </categories>
      <tags>
        <tag>Informatics In Junior</tag>
        <tag>Innovation class</tag>
      </tags>
  </entry>
  <entry>
    <title>第一到八章</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E4%B8%80%E5%88%B0%E5%85%AB%E7%AB%A0/</url>
    <content><![CDATA[<div class="pdfobject-container" data-target="./经济学原理第一到八章.pdf" data-height="500px"></div>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Useful Commands in Linux</title>
    <url>/Linux/Useful-Commands-in-Linux/</url>
    <content><![CDATA[<p>When you install a Linux server or PC, you need to configure the system at first. Here is a collection of useful commands taking Ubuntu as example.</p>
<a id="more"></a>

<h2 id="Common-Commands"><a href="#Common-Commands" class="headerlink" title="Common Commands"></a>Common Commands</h2><h3 id="Change-Directory-cd"><a href="#Change-Directory-cd" class="headerlink" title="Change Directory (cd)"></a>Change Directory (<code>cd</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home/Qjbtiger/files <span class="comment"># change directory to path</span></span><br><span class="line"><span class="built_in">cd</span> .\ <span class="comment"># cd to current directory</span></span><br><span class="line"><span class="built_in">cd</span> ..\ <span class="comment"># cd to parent directory</span></span><br><span class="line"><span class="built_in">cd</span> \ <span class="comment"># cd to root directory</span></span><br><span class="line"><span class="built_in">cd</span> ~ <span class="comment"># cd to current user's home directory</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>Usage</summary>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span>: <span class="built_in">cd</span> [-L|[-P [-e]] [-@]] [dir]</span><br><span class="line">  Change the shell working directory.</span><br><span class="line">  </span><br><span class="line">  Change the current directory to DIR.  The default DIR is the value of the</span><br><span class="line">  HOME shell variable.</span><br><span class="line">  </span><br><span class="line">  The variable CDPATH defines the search path <span class="keyword">for</span> the directory containing</span><br><span class="line">  DIR.  Alternative directory names <span class="keyword">in</span> CDPATH are separated by a colon (:).</span><br><span class="line">  A null directory name is the same as the current directory.  If DIR begins</span><br><span class="line">  with a slash (/), <span class="keyword">then</span> CDPATH is not used.</span><br><span class="line">  </span><br><span class="line">  If the directory is not found, and the shell option `cdable_vars<span class="string">' is set,</span></span><br><span class="line"><span class="string">  the word is assumed to be  a variable name.  If that variable has a value,</span></span><br><span class="line"><span class="string">  its value is used for DIR.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Options:</span></span><br><span class="line"><span class="string">    -L        force symbolic links to be followed: resolve symbolic</span></span><br><span class="line"><span class="string">              links in DIR after processing instances of `..'</span></span><br><span class="line">    -P        use the physical directory structure without following</span><br><span class="line">              symbolic links: resolve symbolic links <span class="keyword">in</span> DIR before</span><br><span class="line">              processing instances of `..<span class="string">'</span></span><br><span class="line"><span class="string">    -e        if the -P option is supplied, and the current working</span></span><br><span class="line"><span class="string">              directory cannot be determined successfully, exit with</span></span><br><span class="line"><span class="string">              a non-zero status</span></span><br><span class="line"><span class="string">    -@        on systems that support it, present a file with extended</span></span><br><span class="line"><span class="string">              attributes as a directory containing the file attributes</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  The default is to follow symbolic links, as if `-L'</span> were specified.</span><br><span class="line">  `..<span class="string">' is processed by removing the immediately previous pathname component</span></span><br><span class="line"><span class="string">  back to a slash or the beginning of DIR.</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">  Exit Status:</span></span><br><span class="line"><span class="string">  Returns 0 if the directory is changed, and if $PWD is set successfully when</span></span><br><span class="line"><span class="string">  -P is used; non-zero otherwise.</span></span><br></pre></td></tr></table></figure>
</details>

<h3 id="List-the-Files-ls"><a href="#List-the-Files-ls" class="headerlink" title="List the Files(ls)"></a>List the Files(<code>ls</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /home/Qjbtiger/files <span class="comment"># list all files in path '/home/Qjbtiger/files'</span></span><br><span class="line">ls ./ <span class="comment"># list all files in current path</span></span><br><span class="line">ls <span class="comment"># same as above</span></span><br><span class="line">ls -l <span class="comment"># list all files in details</span></span><br><span class="line">ls -a <span class="comment"># list all files including hidden files</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>Usage</summary>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: ls [OPTION]... [FILE]...</span><br><span class="line">List information about the FILEs (the current directory by default).</span><br><span class="line">Sort entries alphabetically <span class="keyword">if</span> none of -cftuvSUX nor --sort is specified.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line">  -a, --all                  <span class="keyword">do</span> not ignore entries starting with .</span><br><span class="line">  -A, --almost-all           <span class="keyword">do</span> not list implied . and ..</span><br><span class="line">      --author               with -l, <span class="built_in">print</span> the author of each file</span><br><span class="line">  -b, --escape               <span class="built_in">print</span> C-style escapes <span class="keyword">for</span> nongraphic characters</span><br><span class="line">      --block-size=SIZE      with -l, scale sizes by SIZE when printing them;</span><br><span class="line">                              e.g., <span class="string">'--block-size=M'</span>; see SIZE format below</span><br><span class="line">  -B, --ignore-backups       <span class="keyword">do</span> not list implied entries ending with ~</span><br><span class="line">  -c                         with -lt: sort by, and show, ctime (time of last</span><br><span class="line">                              modification of file status information);</span><br><span class="line">                              with -l: show ctime and sort by name;</span><br><span class="line">                              otherwise: sort by ctime, newest first</span><br><span class="line">  -C                         list entries by columns</span><br><span class="line">      --color[=WHEN]         colorize the output; WHEN can be <span class="string">'always'</span> (default</span><br><span class="line">                              <span class="keyword">if</span> omitted), <span class="string">'auto'</span>, or <span class="string">'never'</span>; more info below</span><br><span class="line">  -d, --directory            list directories themselves, not their contents</span><br><span class="line">  -D, --dired                generate output designed <span class="keyword">for</span> Emacs<span class="string">' dired mode</span></span><br><span class="line"><span class="string">  -f                         do not sort, enable -aU, disable -ls --color</span></span><br><span class="line"><span class="string">  -F, --classify             append indicator (one of */=&gt;@|) to entries</span></span><br><span class="line"><span class="string">      --file-type            likewise, except do not append '</span>*<span class="string">'</span></span><br><span class="line"><span class="string">      --format=WORD          across -x, commas -m, horizontal -x, long -l,</span></span><br><span class="line"><span class="string">                              single-column -1, verbose -l, vertical -C</span></span><br><span class="line"><span class="string">      --full-time            like -l --time-style=full-iso</span></span><br><span class="line"><span class="string">  -g                         like -l, but do not list owner</span></span><br><span class="line"><span class="string">      --group-directories-first</span></span><br><span class="line"><span class="string">                            group directories before files;</span></span><br><span class="line"><span class="string">                              can be augmented with a --sort option, but any</span></span><br><span class="line"><span class="string">                              use of --sort=none (-U) disables grouping</span></span><br><span class="line"><span class="string">  -G, --no-group             in a long listing, don'</span>t <span class="built_in">print</span> group names</span><br><span class="line">  -h, --human-readable       with -l and -s, <span class="built_in">print</span> sizes like 1K 234M 2G etc.</span><br><span class="line">      --si                   likewise, but use powers of 1000 not 1024</span><br><span class="line">  -H, --dereference-command-line</span><br><span class="line">                            follow symbolic links listed on the <span class="built_in">command</span> line</span><br><span class="line">      --dereference-command-line-symlink-to-dir</span><br><span class="line">                            follow each <span class="built_in">command</span> line symbolic link</span><br><span class="line">                              that points to a directory</span><br><span class="line">      --hide=PATTERN         <span class="keyword">do</span> not list implied entries matching shell PATTERN</span><br><span class="line">                              (overridden by -a or -A)</span><br><span class="line">      --hyperlink[=WHEN]     hyperlink file names; WHEN can be <span class="string">'always'</span></span><br><span class="line">                              (default <span class="keyword">if</span> omitted), <span class="string">'auto'</span>, or <span class="string">'never'</span></span><br><span class="line">      --indicator-style=WORD  append indicator with style WORD to entry names:</span><br><span class="line">                              none (default), slash (-p),</span><br><span class="line">                              file-type (--file-type), classify (-F)</span><br><span class="line">  -i, --inode                <span class="built_in">print</span> the index number of each file</span><br><span class="line">  -I, --ignore=PATTERN       <span class="keyword">do</span> not list implied entries matching shell PATTERN</span><br><span class="line">  -k, --kibibytes            default to 1024-byte blocks <span class="keyword">for</span> disk usage;</span><br><span class="line">                              used only with -s and per directory totals</span><br><span class="line">  -l                         use a long listing format</span><br><span class="line">  -L, --dereference          when showing file information <span class="keyword">for</span> a symbolic</span><br><span class="line">                              link, show information <span class="keyword">for</span> the file the link</span><br><span class="line">                              references rather than <span class="keyword">for</span> the link itself</span><br><span class="line">  -m                         fill width with a comma separated list of entries</span><br><span class="line">  -n, --numeric-uid-gid      like -l, but list numeric user and group IDs</span><br><span class="line">  -N, --literal              <span class="built_in">print</span> entry names without quoting</span><br><span class="line">  -o                         like -l, but <span class="keyword">do</span> not list group information</span><br><span class="line">  -p, --indicator-style=slash</span><br><span class="line">                            append / indicator to directories</span><br><span class="line">  -q, --hide-control-chars   <span class="built_in">print</span> ? instead of nongraphic characters</span><br><span class="line">      --show-control-chars   show nongraphic characters as-is (the default,</span><br><span class="line">                              unless program is <span class="string">'ls'</span> and output is a terminal)</span><br><span class="line">  -Q, --quote-name           enclose entry names <span class="keyword">in</span> double quotes</span><br><span class="line">      --quoting-style=WORD   use quoting style WORD <span class="keyword">for</span> entry names:</span><br><span class="line">                              literal, locale, shell, shell-always,</span><br><span class="line">                              shell-escape, shell-escape-always, c, escape</span><br><span class="line">                              (overrides QUOTING_STYLE environment variable)</span><br><span class="line">  -r, --reverse              reverse order <span class="keyword">while</span> sorting</span><br><span class="line">  -R, --recursive            list subdirectories recursively</span><br><span class="line">  -s, --size                 <span class="built_in">print</span> the allocated size of each file, <span class="keyword">in</span> blocks</span><br><span class="line">  -S                         sort by file size, largest first</span><br><span class="line">      --sort=WORD            sort by WORD instead of name: none (-U), size (-S),</span><br><span class="line">                              time (-t), version (-v), extension (-X)</span><br><span class="line">      --time=WORD            with -l, show time as WORD instead of default</span><br><span class="line">                              modification time: atime or access or use (-u);</span><br><span class="line">                              ctime or status (-c); also use specified time</span><br><span class="line">                              as sort key <span class="keyword">if</span> --sort=time (newest first)</span><br><span class="line">      --time-style=TIME_STYLE  time/date format with -l; see TIME_STYLE below</span><br><span class="line">  -t                         sort by modification time, newest first</span><br><span class="line">  -T, --tabsize=COLS         assume tab stops at each COLS instead of 8</span><br><span class="line">  -u                         with -lt: sort by, and show, access time;</span><br><span class="line">                              with -l: show access time and sort by name;</span><br><span class="line">                              otherwise: sort by access time, newest first</span><br><span class="line">  -U                         <span class="keyword">do</span> not sort; list entries <span class="keyword">in</span> directory order</span><br><span class="line">  -v                         natural sort of (version) numbers within text</span><br><span class="line">  -w, --width=COLS           <span class="built_in">set</span> output width to COLS.  0 means no <span class="built_in">limit</span></span><br><span class="line">  -x                         list entries by lines instead of by columns</span><br><span class="line">  -X                         sort alphabetically by entry extension</span><br><span class="line">  -Z, --context              <span class="built_in">print</span> any security context of each file</span><br><span class="line">  -1                         list one file per line.  Avoid <span class="string">'\n'</span> with -q or -b</span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">      --version  output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">The SIZE argument is an <span class="built_in">integer</span> and optional unit (example: 10K is 10*1024).</span><br><span class="line">Units are K,M,G,T,P,E,Z,Y (powers of 1024) or KB,MB,... (powers of 1000).</span><br><span class="line"></span><br><span class="line">The TIME_STYLE argument can be full-iso, long-iso, iso, locale, or +FORMAT.</span><br><span class="line">FORMAT is interpreted like <span class="keyword">in</span> date(1).  If FORMAT is FORMAT1&lt;newline&gt;FORMAT2,</span><br><span class="line"><span class="keyword">then</span> FORMAT1 applies to non-recent files and FORMAT2 to recent files.</span><br><span class="line">TIME_STYLE prefixed with <span class="string">'posix-'</span> takes effect only outside the POSIX locale.</span><br><span class="line">Also the TIME_STYLE environment variable sets the default style to use.</span><br><span class="line"></span><br><span class="line">Using color to distinguish file types is disabled both by default and</span><br><span class="line">with --color=never.  With --color=auto, ls emits color codes only when</span><br><span class="line">standard output is connected to a terminal.  The LS_COLORS environment</span><br><span class="line">variable can change the settings.  Use the dircolors <span class="built_in">command</span> to <span class="built_in">set</span> it.</span><br><span class="line"></span><br><span class="line">Exit status:</span><br><span class="line">0  <span class="keyword">if</span> OK,</span><br><span class="line">1  <span class="keyword">if</span> minor problems (e.g., cannot access subdirectory),</span><br><span class="line">2  <span class="keyword">if</span> serious trouble (e.g., cannot access <span class="built_in">command</span>-line argument).</span><br></pre></td></tr></table></figure>
</details>

<h3 id="Make-Directory-mkdir"><a href="#Make-Directory-mkdir" class="headerlink" title="Make Directory (mkdir)"></a>Make Directory (<code>mkdir</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir /home/Qjbtiger/files/newDirectory <span class="comment"># make directory named 'newDirectory' in path '/home/Qjbtiger/files'</span></span><br><span class="line">mkdir ./newDirectory <span class="comment"># make directory named 'newDirectory' in current path</span></span><br><span class="line">mkdir newDirectory <span class="comment"># same as above</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>Usage</summary>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: mkdir [OPTION]... DIRECTORY...</span><br><span class="line">Create the DIRECTORY(ies), <span class="keyword">if</span> they <span class="keyword">do</span> not already exist.</span><br><span class="line"></span><br><span class="line">Mandatory arguments to long options are mandatory <span class="keyword">for</span> short options too.</span><br><span class="line">  -m, --mode=MODE   <span class="built_in">set</span> file mode (as <span class="keyword">in</span> chmod), not a=rwx - <span class="built_in">umask</span></span><br><span class="line">  -p, --parents     no error <span class="keyword">if</span> existing, make parent directories as needed</span><br><span class="line">  -v, --verbose     <span class="built_in">print</span> a message <span class="keyword">for</span> each created directory</span><br><span class="line">  -Z                   <span class="built_in">set</span> SELinux security context of each created directory</span><br><span class="line">                         to the default <span class="built_in">type</span></span><br><span class="line">      --context[=CTX]  like -Z, or <span class="keyword">if</span> CTX is specified <span class="keyword">then</span> <span class="built_in">set</span> the SELinux</span><br><span class="line">                         or SMACK security context to CTX</span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">      --version  output version information and <span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
</details>

<h3 id="Delete-Files-or-Directories-rm"><a href="#Delete-Files-or-Directories-rm" class="headerlink" title="Delete Files or Directories(rm)"></a>Delete Files or Directories(<code>rm</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm /home/Qjbtiger/files/fileReadyToDelete.txt <span class="comment"># delete the file named 'fileReadyToDelete' in path '/home/Qjbtiger/files'</span></span><br><span class="line">rm ./fileReadyToDelete.txt <span class="comment"># delete the file named 'fileReadyToDelete' in current path</span></span><br><span class="line">rm ./* <span class="comment"># delete all files in current path. Command 'rm' support for wildcard character</span></span><br><span class="line">rm -r /home/Qjbtiger/files/DirectoryReadyToDelete <span class="comment"># delete the directory named 'DirectoryReadyToDelete' in path '/home/Qjbtiger/files'. '-r' means deleting directories and their contents recursively</span></span><br><span class="line">rm -rf /* <span class="comment"># ready to run away~~</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>Usage</summary>

  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: rm [OPTION]... [FILE]...</span><br><span class="line">Remove (unlink) the FILE(s).</span><br><span class="line"></span><br><span class="line">  -f, --force           ignore nonexistent files and arguments, never prompt</span><br><span class="line">  -i                    prompt before every removal</span><br><span class="line">  -I                    prompt once before removing more than three files, or</span><br><span class="line">                          when removing recursively; less intrusive than -i,</span><br><span class="line">                          <span class="keyword">while</span> still giving protection against most mistakes</span><br><span class="line">      --interactive[=WHEN]  prompt according to WHEN: never, once (-I), or</span><br><span class="line">                          always (-i); without WHEN, prompt always</span><br><span class="line">      --one-file-system  when removing a hierarchy recursively, skip any</span><br><span class="line">                          directory that is on a file system different from</span><br><span class="line">                          that of the corresponding <span class="built_in">command</span> line argument</span><br><span class="line">      --no-preserve-root  <span class="keyword">do</span> not treat <span class="string">'/'</span> specially</span><br><span class="line">      --preserve-root[=all]  <span class="keyword">do</span> not remove <span class="string">'/'</span> (default);</span><br><span class="line">                              with <span class="string">'all'</span>, reject any <span class="built_in">command</span> line argument</span><br><span class="line">                              on a separate device from its parent</span><br><span class="line">  -r, -R, --recursive   remove directories and their contents recursively</span><br><span class="line">  -d, --dir             remove empty directories</span><br><span class="line">  -v, --verbose         explain what is being <span class="keyword">done</span></span><br><span class="line">      --<span class="built_in">help</span>     display this <span class="built_in">help</span> and <span class="built_in">exit</span></span><br><span class="line">      --version  output version information and <span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line">By default, rm does not remove directories.  Use the --recursive (-r or -R)</span><br><span class="line">option to remove each listed directory, too, along with all of its contents.</span><br><span class="line"></span><br><span class="line">To remove a file whose name starts with a <span class="string">'-'</span>, <span class="keyword">for</span> example <span class="string">'-foo'</span>,</span><br><span class="line">use one of these commands:</span><br><span class="line">  rm -- -foo</span><br><span class="line"></span><br><span class="line">  rm ./-foo</span><br><span class="line"></span><br><span class="line">Note that <span class="keyword">if</span> you use rm to remove a file, it might be possible to recover</span><br><span class="line">some of its contents, given sufficient expertise and/or time.  For greater</span><br><span class="line">assurance that the contents are truly unrecoverable, consider using shred.</span><br></pre></td></tr></table></figure>
</details>

<h3 id="Compression-amp-Decompression"><a href="#Compression-amp-Decompression" class="headerlink" title="Compression &amp; Decompression"></a>Compression &amp; Decompression</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -cf /home/Qjbtiger/tmp.tar /home/Qjbtiger/tmp.txt <span class="comment"># create new archive (no compression) and '-f' is usually necessary</span></span><br><span class="line">tar -zcf /home/Qjbtiger/tmp.tar.gz /home/Qjbtiger/tmp.txt <span class="comment"># create new archive (with gzip compression)</span></span><br><span class="line">tar -jcf /home/Qjbtiger/tmp.tar.bz2 /home/Qjbtiger/tmp.txt <span class="comment"># create new archive (with bzip2 compression)</span></span><br><span class="line">tar -xf /home/Qjbtiger/tmp.tar <span class="comment"># extract the archive (no compression)</span></span><br><span class="line">tar -zxf /home/Qjbtiger/tmp.tar.gz <span class="comment"># extract the archive (with gzip compression)</span></span><br><span class="line">tar -jxf /home/Qjbtiger/tmp.tar.bz2 <span class="comment"># extract the archive (with bzip2 compression)</span></span><br><span class="line">tar -zvxf /home/Qjbtiger/tmp.tar.gz <span class="comment"># with verbose</span></span><br><span class="line"></span><br><span class="line">zip /home/Qjbtiger/tmp.zip /home/Qjbtiger/tmp.txt <span class="comment"># compress files</span></span><br><span class="line">zip -r /home/Qjbtiger/tmp.zip /home/Qjbtiger/tmp <span class="comment"># compress directory</span></span><br><span class="line">unzip /home/Qjbtiger/tmp.zip <span class="comment"># decompress the archive</span></span><br></pre></td></tr></table></figure>

<h3 id="Network-Related"><a href="#Network-Related" class="headerlink" title="Network Related"></a>Network Related</h3><h4 id="Check-ip-Address-ifconfig"><a href="#Check-ip-Address-ifconfig" class="headerlink" title="Check ip Address (ifconfig)"></a>Check ip Address (<code>ifconfig</code>)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<h4 id="Show-Network-Status-netstat"><a href="#Show-Network-Status-netstat" class="headerlink" title="Show Network Status (netstat)"></a>Show Network Status (<code>netstat</code>)</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">netstat <span class="comment"># show active connections</span></span><br><span class="line">netstat -a <span class="comment"># show all ports including Listened and not listened</span></span><br><span class="line">netstat -at <span class="comment"># show all port of tcp links</span></span><br><span class="line">netstat -au <span class="comment"># show all port of udp links</span></span><br><span class="line">netstat -l <span class="comment"># show all listened ports</span></span><br><span class="line">netstat -s <span class="comment"># show statustic information</span></span><br><span class="line">netstat -p <span class="comment"># show PID and process name</span></span><br><span class="line">netstat -n <span class="comment"># show ip adress instead of hosts/ports/users name</span></span><br><span class="line"></span><br><span class="line">netstat -tulpn <span class="comment"># usually use</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>Usage</summary>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">usage: netstat [-vWeenNcCF] [&lt;Af&gt;] -r         netstat &#123;-V|--version|-h|--<span class="built_in">help</span>&#125;</span><br><span class="line">       netstat [-vWnNcaeol] [&lt;Socket&gt; ...]</span><br><span class="line">       netstat &#123; [-vWeenNac] -i | [-cnNe] -M | -s [-6tuw] &#125;</span><br><span class="line"></span><br><span class="line">        -r, --route              display routing table</span><br><span class="line">        -i, --interfaces         display interface table</span><br><span class="line">        -g, --groups             display multicast group memberships</span><br><span class="line">        -s, --statistics         display networking statistics (like SNMP)</span><br><span class="line">        -M, --masquerade         display masqueraded connections</span><br><span class="line"></span><br><span class="line">        -v, --verbose            be verbose</span><br><span class="line">        -W, --wide               don<span class="string">'t truncate IP addresses</span></span><br><span class="line"><span class="string">        -n, --numeric            don'</span>t resolve names</span><br><span class="line">        --numeric-hosts          don<span class="string">'t resolve host names</span></span><br><span class="line"><span class="string">        --numeric-ports          don'</span>t resolve port names</span><br><span class="line">        --numeric-users          don<span class="string">'t resolve user names</span></span><br><span class="line"><span class="string">        -N, --symbolic           resolve hardware names</span></span><br><span class="line"><span class="string">        -e, --extend             display other/more information</span></span><br><span class="line"><span class="string">        -p, --programs           display PID/Program name for sockets</span></span><br><span class="line"><span class="string">        -o, --timers             display timers</span></span><br><span class="line"><span class="string">        -c, --continuous         continuous listing</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        -l, --listening          display listening server sockets</span></span><br><span class="line"><span class="string">        -a, --all                display all sockets (default: connected)</span></span><br><span class="line"><span class="string">        -F, --fib                display Forwarding Information Base (default)</span></span><br><span class="line"><span class="string">        -C, --cache              display routing cache instead of FIB</span></span><br><span class="line"><span class="string">        -Z, --context            display SELinux security context for sockets</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  &lt;Socket&gt;=&#123;-t|--tcp&#125; &#123;-u|--udp&#125; &#123;-U|--udplite&#125; &#123;-S|--sctp&#125; &#123;-w|--raw&#125;</span></span><br><span class="line"><span class="string">           &#123;-x|--unix&#125; --ax25 --ipx --netrom</span></span><br><span class="line"><span class="string">  &lt;AF&gt;=Use '</span>-6|-4<span class="string">' or '</span>-A &lt;af&gt;<span class="string">' or '</span>--&lt;af&gt;<span class="string">'; default: inet</span></span><br><span class="line"><span class="string">  List of possible address families (which support routing):</span></span><br><span class="line"><span class="string">    inet (DARPA Internet) inet6 (IPv6) ax25 (AMPR AX.25) </span></span><br><span class="line"><span class="string">    netrom (AMPR NET/ROM) ipx (Novell IPX) ddp (Appletalk DDP) </span></span><br><span class="line"><span class="string">    x25 (CCITT X.25)</span></span><br></pre></td></tr></table></figure>
</details>

<h3 id="System-Service-systemctl"><a href="#System-Service-systemctl" class="headerlink" title="System Service (systemctl)"></a>System Service (<code>systemctl</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start smbd <span class="comment"># start service 'smbd'</span></span><br><span class="line">systemctl stop smbd <span class="comment"># stop service 'smbd'</span></span><br><span class="line">systemctl restart smbd <span class="comment"># restart service 'smbd'</span></span><br><span class="line">systemctl reload smbd <span class="comment"># reload config file of service 'smbd'</span></span><br><span class="line">systemctl status smbd <span class="comment"># start service 'smbd'</span></span><br><span class="line">systemctl <span class="built_in">enable</span> smbd <span class="comment"># start service 'smbd' when starting up</span></span><br><span class="line">systemctl <span class="built_in">disable</span> smbd <span class="comment"># don't start service 'smbd' when starting up</span></span><br></pre></td></tr></table></figure>

<details>
  <summary>Usage</summary>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl [OPTIONS...] COMMAND ...</span><br><span class="line"></span><br><span class="line">Query or send control commands to the system manager.</span><br><span class="line"></span><br><span class="line">Unit Commands:</span><br><span class="line">  list-units [PATTERN...]             List units currently <span class="keyword">in</span> memory</span><br><span class="line">  list-sockets [PATTERN...]           List socket units currently <span class="keyword">in</span> memory,</span><br><span class="line">                                      ordered by address</span><br><span class="line">  list-timers [PATTERN...]            List timer units currently <span class="keyword">in</span> memory,</span><br><span class="line">                                      ordered by next elapse</span><br><span class="line">  start UNIT...                       Start (activate) one or more units</span><br><span class="line">  stop UNIT...                        Stop (deactivate) one or more units</span><br><span class="line">  reload UNIT...                      Reload one or more units</span><br><span class="line">  restart UNIT...                     Start or restart one or more units</span><br><span class="line">  try-restart UNIT...                 Restart one or more units <span class="keyword">if</span> active</span><br><span class="line">  reload-or-restart UNIT...           Reload one or more units <span class="keyword">if</span> possible,</span><br><span class="line">                                      otherwise start or restart</span><br><span class="line">  try-reload-or-restart UNIT...       If active, reload one or more units,</span><br><span class="line">                                      <span class="keyword">if</span> supported, otherwise restart</span><br><span class="line">  isolate UNIT                        Start one unit and stop all others</span><br><span class="line">  <span class="built_in">kill</span> UNIT...                        Send signal to processes of a unit</span><br><span class="line">  clean UNIT...                       Clean runtime, cache, state, logs or</span><br><span class="line">                                      configuration of unit</span><br><span class="line">  is-active PATTERN...                Check whether units are active</span><br><span class="line">  is-failed PATTERN...                Check whether units are failed</span><br><span class="line">  status [PATTERN...|PID...]          Show runtime status of one or more units</span><br><span class="line">  show [PATTERN...|JOB...]            Show properties of one or more</span><br><span class="line">                                      units/<span class="built_in">jobs</span> or the manager</span><br><span class="line">  cat PATTERN...                      Show files and drop-ins of specified units</span><br><span class="line">  <span class="built_in">set</span>-property UNIT PROPERTY=VALUE... Sets one or more properties of a unit</span><br><span class="line">  <span class="built_in">help</span> PATTERN...|PID...              Show manual <span class="keyword">for</span> one or more units</span><br><span class="line">  reset-failed [PATTERN...]           Reset failed state <span class="keyword">for</span> all, one, or more</span><br><span class="line">                                      units</span><br><span class="line">  list-dependencies [UNIT...]         Recursively show units <span class="built_in">which</span> are required</span><br><span class="line">                                      or wanted by the units or by <span class="built_in">which</span> those</span><br><span class="line">                                      units are required or wanted</span><br><span class="line">Unit File Commands:</span><br><span class="line">  list-unit-files [PATTERN...]        List installed unit files</span><br><span class="line">  <span class="built_in">enable</span> [UNIT...|PATH...]            Enable one or more unit files</span><br><span class="line">  <span class="built_in">disable</span> UNIT...                     Disable one or more unit files</span><br><span class="line">  reenable UNIT...                    Reenable one or more unit files</span><br><span class="line">  preset UNIT...                      Enable/<span class="built_in">disable</span> one or more unit files</span><br><span class="line">                                      based on preset configuration</span><br><span class="line">  preset-all                          Enable/<span class="built_in">disable</span> all unit files based on</span><br><span class="line">                                      preset configuration</span><br><span class="line">  is-enabled UNIT...                  Check whether unit files are enabled</span><br><span class="line">  mask UNIT...                        Mask one or more units</span><br><span class="line">  unmask UNIT...                      Unmask one or more units</span><br><span class="line">  link PATH...                        Link one or more units files into</span><br><span class="line">                                      the search path</span><br><span class="line">  revert UNIT...                      Revert one or more unit files to vendor</span><br><span class="line">                                      version</span><br><span class="line">  add-wants TARGET UNIT...            Add <span class="string">'Wants'</span> dependency <span class="keyword">for</span> the target</span><br><span class="line">                                      on specified one or more units</span><br><span class="line">  add-requires TARGET UNIT...         Add <span class="string">'Requires'</span> dependency <span class="keyword">for</span> the target</span><br><span class="line">                                      on specified one or more units</span><br><span class="line">  edit UNIT...                        Edit one or more unit files</span><br><span class="line">  get-default                         Get the name of the default target</span><br><span class="line">  <span class="built_in">set</span>-default TARGET                  Set the default target</span><br><span class="line"></span><br><span class="line">Machine Commands:</span><br><span class="line">  list-machines [PATTERN...]          List <span class="built_in">local</span> containers and host</span><br><span class="line"></span><br><span class="line">Job Commands:</span><br><span class="line">  list-jobs [PATTERN...]              List <span class="built_in">jobs</span></span><br><span class="line">  cancel [JOB...]                     Cancel all, one, or more <span class="built_in">jobs</span></span><br><span class="line"></span><br><span class="line">Environment Commands:</span><br><span class="line">  show-environment                    Dump environment</span><br><span class="line">  <span class="built_in">set</span>-environment VARIABLE=VALUE...   Set one or more environment variables</span><br><span class="line">  <span class="built_in">unset</span>-environment VARIABLE...       Unset one or more environment variables</span><br><span class="line">  import-environment [VARIABLE...]    Import all or some environment variables</span><br><span class="line"></span><br><span class="line">Manager State Commands:</span><br><span class="line">  daemon-reload                       Reload systemd manager configuration</span><br><span class="line">  daemon-reexec                       Reexecute systemd manager</span><br><span class="line">  <span class="built_in">log</span>-level [LEVEL]                   Get/<span class="built_in">set</span> logging threshold <span class="keyword">for</span> manager</span><br><span class="line">  <span class="built_in">log</span>-target [TARGET]                 Get/<span class="built_in">set</span> logging target <span class="keyword">for</span> manager</span><br><span class="line">  service-watchdogs [BOOL]            Get/<span class="built_in">set</span> service watchdog state</span><br><span class="line"></span><br><span class="line">System Commands:</span><br><span class="line">  is-system-running                   Check whether system is fully running</span><br><span class="line">  default                             Enter system default mode</span><br><span class="line">  rescue                              Enter system rescue mode</span><br><span class="line">  emergency                           Enter system emergency mode</span><br><span class="line">  halt                                Shut down and halt the system</span><br><span class="line">  poweroff                            Shut down and power-off the system</span><br><span class="line">  reboot [ARG]                        Shut down and reboot the system</span><br><span class="line">  kexec                               Shut down and reboot the system with kexec</span><br><span class="line">  <span class="built_in">exit</span> [EXIT_CODE]                    Request user instance or container <span class="built_in">exit</span></span><br><span class="line">  switch-root ROOT [INIT]             Change to a different root file system</span><br><span class="line">  <span class="built_in">suspend</span>                             Suspend the system</span><br><span class="line">  hibernate                           Hibernate the system</span><br><span class="line">  hybrid-sleep                        Hibernate and <span class="built_in">suspend</span> the system</span><br><span class="line">  <span class="built_in">suspend</span>-then-hibernate              Suspend the system, wake after a period of</span><br><span class="line">                                      time, and hibernate</span><br><span class="line">Options:</span><br><span class="line">  -h --<span class="built_in">help</span>              Show this <span class="built_in">help</span></span><br><span class="line">     --version           Show package version</span><br><span class="line">     --system            Connect to system manager</span><br><span class="line">     --user              Connect to user service manager</span><br><span class="line">  -H --host=[USER@]HOST  Operate on remote host</span><br><span class="line">  -M --machine=CONTAINER Operate on a <span class="built_in">local</span> container</span><br><span class="line">  -t --<span class="built_in">type</span>=TYPE         List units of a particular <span class="built_in">type</span></span><br><span class="line">     --state=STATE       List units with particular LOAD or SUB or ACTIVE state</span><br><span class="line">     --failed            Shorcut <span class="keyword">for</span> --state=failed</span><br><span class="line">  -p --property=NAME     Show only properties by this name</span><br><span class="line">  -a --all               Show all properties/all units currently <span class="keyword">in</span> memory,</span><br><span class="line">                         including dead/empty ones. To list all units installed</span><br><span class="line">                         on the system, use <span class="string">'list-unit-files'</span> instead.</span><br><span class="line">  -l --full              Don<span class="string">'t ellipsize unit names on output</span></span><br><span class="line"><span class="string">  -r --recursive         Show unit list of host and local containers</span></span><br><span class="line"><span class="string">     --reverse           Show reverse dependencies with '</span>list-dependencies<span class="string">'</span></span><br><span class="line"><span class="string">     --with-dependencies Show unit dependencies with '</span>status<span class="string">', '</span>cat<span class="string">',</span></span><br><span class="line"><span class="string">                         '</span>list-units<span class="string">', and '</span>list-unit-files<span class="string">'.</span></span><br><span class="line"><span class="string">     --job-mode=MODE     Specify how to deal with already queued jobs, when</span></span><br><span class="line"><span class="string">                         queueing a new job</span></span><br><span class="line"><span class="string">  -T --show-transaction  When enqueuing a unit job, show full transaction</span></span><br><span class="line"><span class="string">     --show-types        When showing sockets, explicitly show their type</span></span><br><span class="line"><span class="string">     --value             When showing properties, only print the value</span></span><br><span class="line"><span class="string">  -i --ignore-inhibitors When shutting down or sleeping, ignore inhibitors</span></span><br><span class="line"><span class="string">     --kill-who=WHO      Whom to send signal to</span></span><br><span class="line"><span class="string">  -s --signal=SIGNAL     Which signal to send</span></span><br><span class="line"><span class="string">     --what=RESOURCES    Which types of resources to remove</span></span><br><span class="line"><span class="string">     --now               Start or stop unit after enabling or disabling it</span></span><br><span class="line"><span class="string">     --dry-run           Only print what would be done</span></span><br><span class="line"><span class="string">                         Currently supported by verbs: halt, poweroff, reboot,</span></span><br><span class="line"><span class="string">                             kexec, suspend, hibernate, suspend-then-hibernate,</span></span><br><span class="line"><span class="string">                             hybrid-sleep, default, rescue, emergency, and exit.</span></span><br><span class="line"><span class="string">  -q --quiet             Suppress output</span></span><br><span class="line"><span class="string">     --wait              For (re)start, wait until service stopped again</span></span><br><span class="line"><span class="string">                         For is-system-running, wait until startup is completed</span></span><br><span class="line"><span class="string">     --no-block          Do not wait until operation finished</span></span><br><span class="line"><span class="string">     --no-wall           Don'</span>t send wall message before halt/power-off/reboot</span><br><span class="line">     --no-reload         Don<span class="string">'t reload daemon after en-/dis-abling unit files</span></span><br><span class="line"><span class="string">     --no-legend         Do not print a legend (column headers and hints)</span></span><br><span class="line"><span class="string">     --no-pager          Do not pipe output into a pager</span></span><br><span class="line"><span class="string">     --no-ask-password   Do not ask for system passwords</span></span><br><span class="line"><span class="string">     --global            Enable/disable/mask unit files globally</span></span><br><span class="line"><span class="string">     --runtime           Enable/disable/mask unit files temporarily until next</span></span><br><span class="line"><span class="string">                         reboot</span></span><br><span class="line"><span class="string">  -f --force             When enabling unit files, override existing symlinks</span></span><br><span class="line"><span class="string">                         When shutting down, execute action immediately</span></span><br><span class="line"><span class="string">     --preset-mode=      Apply only enable, only disable, or all presets</span></span><br><span class="line"><span class="string">     --root=PATH         Enable/disable/mask unit files in the specified root</span></span><br><span class="line"><span class="string">                         directory</span></span><br><span class="line"><span class="string">  -n --lines=INTEGER     Number of journal entries to show</span></span><br><span class="line"><span class="string">  -o --output=STRING     Change journal output mode (short, short-precise,</span></span><br><span class="line"><span class="string">                             short-iso, short-iso-precise, short-full,</span></span><br><span class="line"><span class="string">                             short-monotonic, short-unix,</span></span><br><span class="line"><span class="string">                             verbose, export, json, json-pretty, json-sse, cat)</span></span><br><span class="line"><span class="string">     --firmware-setup    Tell the firmware to show the setup menu on next boot</span></span><br><span class="line"><span class="string">     --boot-loader-menu=TIME</span></span><br><span class="line"><span class="string">                         Boot into boot loader menu on next boot</span></span><br><span class="line"><span class="string">     --boot-loader-entry=NAME</span></span><br><span class="line"><span class="string">                         Boot into a specific boot loader entry on next boot</span></span><br><span class="line"><span class="string">     --plain             Print unit dependencies as a list instead of a tree</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">See the systemctl(1) man page for details.</span></span><br></pre></td></tr></table></figure>
</details>

<h2 id="User-Management"><a href="#User-Management" class="headerlink" title="User Management"></a>User Management</h2><h3 id="Add-New-User"><a href="#Add-New-User" class="headerlink" title="Add (New) User"></a>Add (New) User</h3><p>Make sure you do it by <strong>Root</strong> user or add <code>sudo</code> before the commands below.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser newUserName</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">adduser temp</span><br><span class="line">Adding user `temp<span class="string">' ...</span></span><br><span class="line"><span class="string">Adding new group `temp'</span> (1001) ...</span><br><span class="line">Adding new user `temp<span class="string">' (1001) with group `temp'</span> ...</span><br><span class="line">Creating home directory `/home/temp<span class="string">' ...</span></span><br><span class="line"><span class="string">Copying files from `/etc/skel'</span> ...</span><br><span class="line">New password: <span class="comment"># input password</span></span><br><span class="line">Retype new password: </span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information <span class="keyword">for</span> temp</span><br><span class="line">Enter the new value, or press ENTER <span class="keyword">for</span> the default</span><br><span class="line">        Full Name []: <span class="comment"># input information or press 'Enter' to leave a blank</span></span><br><span class="line">        Room Number []: </span><br><span class="line">        Work Phone []: </span><br><span class="line">        Home Phone []: </span><br><span class="line">        Other []: </span><br><span class="line">Is the information correct? [Y/n] Y <span class="comment"># input 'Y'</span></span><br></pre></td></tr></table></figure>

<h3 id="Delete-User"><a href="#Delete-User" class="headerlink" title="Delete User"></a>Delete User</h3><p>Make sure you do it by <strong>Root</strong> user or add <code>sudo</code> before the commands below.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">userdel deleteUseName <span class="comment"># delete the user named 'deleteUseName' but its home directory won't be delete.</span></span><br><span class="line">userdel -r deleteUserName <span class="comment"># delete the user named 'deleteUseName' and its home directory will be delete as well.</span></span><br></pre></td></tr></table></figure>

<h2 id="Setting-SSH-Transport"><a href="#Setting-SSH-Transport" class="headerlink" title="Setting SSH Transport"></a>Setting SSH Transport</h2><h3 id="Add-Key"><a href="#Add-Key" class="headerlink" title="Add Key"></a>Add Key</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># generate key</span></span><br><span class="line">ssh-keygen <span class="comment"># input command 1</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> the key is (/home/qjbtiger/.ssh/id_rsa): <span class="comment"># just press 'Enter'</span></span><br><span class="line">Created directory <span class="string">'/home/qjbtiger/.ssh'</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment"># input passphrase or press 'Enter' to leave a blank </span></span><br><span class="line">Enter same passphrase again: <span class="comment"># same as above</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /home/qjbtiger/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /home/qjbtiger/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># install public key</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh <span class="comment"># input command 2 &amp; 3</span></span><br><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional step</span></span><br><span class="line">chmod 600 authorized_keys</span><br><span class="line">chmod 700 ~/.ssh</span><br></pre></td></tr></table></figure>

<p>Make sure you do it by <strong>Root</strong> user or add <code>sudo</code> before the commands below.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setting ssh config file</span></span><br><span class="line">vi /etc/ssh/sshd_config <span class="comment"># input command 4</span></span><br><span class="line"></span><br><span class="line">RSAAuthentication yes <span class="comment"># enable RSA authentication</span></span><br><span class="line">PubkeyAuthentication yes <span class="comment"># allow public key authentication</span></span><br><span class="line">PermitRootLogin yes <span class="comment"># allow Root user log in</span></span><br><span class="line">PasswordAuthentication yes <span class="comment"># allow log in by password</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># restart ssh service</span></span><br><span class="line">service sshd restart <span class="comment"># input command 5</span></span><br></pre></td></tr></table></figure>

<p>Download the private key file ‘id_rsa’ to local PC. If you use <strong>PuTTY</strong> or some tools like this, you need to convert the file to new format by <strong>PuTTYGen</strong> which PuTTY can recognize.</p>
<h2 id="Setting-sudo-Command"><a href="#Setting-sudo-Command" class="headerlink" title="Setting sudo Command"></a>Setting <code>sudo</code> Command</h2><p>Make sure you do it by <strong>Root</strong> user or add <code>sudo</code> before the commands below.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root	ALL=(ALL:ALL) ALL</span><br><span class="line">qjbtiger ALL=(ALL:ALL) ALL</span><br><span class="line"><span class="comment">#----Add the user here! The first ALL means all hosts. The second ALL means all users can be used to exxcute commands. The third ALL means all groups can be used to exxcute commands. The fourth ALL means ALL commands can be executed----#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Allow members of group sudo to execute any command</span></span><br><span class="line">%sudo	ALL=(ALL:ALL) ALL</span><br><span class="line"><span class="comment">#----Add the group here!----#</span></span><br></pre></td></tr></table></figure>

<h2 id="Setting-SFTP-vsftpd"><a href="#Setting-SFTP-vsftpd" class="headerlink" title="Setting SFTP (vsftpd)"></a>Setting SFTP (<code>vsftpd</code>)</h2><h3 id="First-Setting"><a href="#First-Setting" class="headerlink" title="First Setting"></a>First Setting</h3><p>If necessary, it is recommanded to do it by <strong>Root</strong> user or add <code>sudo</code> before the commands below, unless only one local user uses it.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># optional step</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># install vsftpd</span></span><br><span class="line">apt-get install vsftpd <span class="comment"># input command 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># config SFTP config file</span></span><br><span class="line">vi /etc/vsftpd.conf <span class="comment"># input command 2</span></span><br><span class="line"></span><br><span class="line">anonymous_enable=NO <span class="comment"># forbid anonymous user log in</span></span><br><span class="line">local_enable=YES <span class="comment"># IMPORTANT. allow loacl user log in</span></span><br><span class="line">write_enable=YES <span class="comment"># allow write (or delete) files</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># chroot (optional)</span></span><br><span class="line">chroot_local_user=YES <span class="comment"># restrict local users to their home directories (Root directory is not allowed)</span></span><br><span class="line">allow_writeable_chroot=YES <span class="comment"># allow to write in root directory</span></span><br><span class="line">chroot_list_enable=YES <span class="comment"># users in  files is forbidden to change Root directory</span></span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list <span class="comment"># file path in '/etc/vsftpd/chroot_list'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># userlist (optional)</span></span><br><span class="line">userlist_enable=YES</span><br><span class="line">userlist_file=/etc/vsftpd/user_list <span class="comment"># add users alled to log in path '/etc/vsftpd.user_list'</span></span><br><span class="line">userlist_deny=NO</span><br><span class="line"></span><br><span class="line"><span class="comment"># optional</span></span><br><span class="line">local_root=/home/<span class="variable">$USER</span> <span class="comment"># the directory when user log in, default is '/home/$USER'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># restart vsftpd service</span></span><br><span class="line">service vsftpd restart <span class="comment"># input command 3</span></span><br></pre></td></tr></table></figure>

<h3 id="Common-Commands-1"><a href="#Common-Commands-1" class="headerlink" title="Common Commands"></a>Common Commands</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service vsftpd start <span class="comment"># start</span></span><br><span class="line">service vsftpd stop <span class="comment"># stop</span></span><br><span class="line">service vsftpd status <span class="comment"># check status</span></span><br><span class="line">service vsftpd restart <span class="comment"># restart</span></span><br></pre></td></tr></table></figure>

<h3 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h3><p>Remerber to allow port 20/21 and 30000:31000 when configuring firewall. If necessary, you can new a user specific to SFTP</p>
<h2 id="Setting-Samba-Server-samba"><a href="#Setting-Samba-Server-samba" class="headerlink" title="Setting Samba Server (samba)"></a>Setting Samba Server (<code>samba</code>)</h2><p><strong>ATTENTION</strong>: The default port 139/445, which is used by smb service, is forbidden by broadband operator in China, and the clients of Windows is not support for changing ports of smb service. So it is recommanded to use it in <strong>LAN</strong> instead of public network.</p>
<p>Make sure you do it by <strong>Root</strong> user or add <code>sudo</code> before the commands below.</p>
<h3 id="First-Setting-1"><a href="#First-Setting-1" class="headerlink" title="First Setting"></a>First Setting</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># optional step</span></span><br><span class="line">apt-get update</span><br><span class="line">apt-get upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># install samba</span></span><br><span class="line">apt-get install samba <span class="comment"># input command 1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># edit config file</span></span><br><span class="line">vi /etc/samba/smb.conf <span class="comment"># input command 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add those words at the end of config file</span></span><br><span class="line">[share]</span><br><span class="line">  path = /home/qjbtiger</span><br><span class="line">  valid users = qjbtiger <span class="comment"># the user name you allow</span></span><br><span class="line">  available = yes</span><br><span class="line">  browseable = yes</span><br><span class="line">  public = no <span class="comment"># need password to log in</span></span><br><span class="line">  writable = yes</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># check config file is correct or not (optional)</span></span><br><span class="line">testparm</span><br><span class="line"></span><br><span class="line"><span class="comment"># add share user</span></span><br><span class="line">smbpasswd -a qjbtiger <span class="comment"># input command 3</span></span><br><span class="line">New SMB password: <span class="comment"># input password</span></span><br><span class="line">Retype new SMB password:</span><br><span class="line">Added user qjbtiger.</span><br><span class="line"></span><br><span class="line"><span class="comment"># restart smb service</span></span><br><span class="line">systemctl reload smbd nmbd <span class="comment"># input command 4</span></span><br></pre></td></tr></table></figure>

<h3 id="Common-Commands-2"><a href="#Common-Commands-2" class="headerlink" title="Common Commands"></a>Common Commands</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl start smbd nmbd <span class="comment"># start samba</span></span><br><span class="line">systemctl stop smbd nmbd <span class="comment"># stop samba</span></span><br><span class="line">systemctl restart smbd nmbd <span class="comment"># restart samba</span></span><br><span class="line">systemctl reload smbd nmbd <span class="comment"># reload config file</span></span><br><span class="line"></span><br><span class="line">systemctl status smbd nmbd <span class="comment"># check samba status</span></span><br><span class="line">smbstatus <span class="comment"># same as above</span></span><br></pre></td></tr></table></figure>

<h3 id="Other-1"><a href="#Other-1" class="headerlink" title="Other"></a>Other</h3><p>Remerber to allow port 139/445 when configuring firewall. If necessary, you can new a user specific to samba.</p>
<p>Or,</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw allow <span class="string">'Samba'</span></span><br></pre></td></tr></table></figure>

<h2 id="Setting-Firewall-ufw"><a href="#Setting-Firewall-ufw" class="headerlink" title="Setting Firewall (ufw)"></a>Setting Firewall (<code>ufw</code>)</h2><p>Make sure you do it by <strong>Root</strong> user or add <code>sudo</code> before the commands below.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ufw <span class="built_in">enable</span> <span class="comment"># start firewall</span></span><br><span class="line">ufw <span class="built_in">disable</span> <span class="comment"># stop firewall</span></span><br><span class="line">ufw reload <span class="comment"># restart firewall</span></span><br><span class="line">ufw status <span class="comment"># check status</span></span><br><span class="line">ufw allow 22 <span class="comment"># allow port 22</span></span><br><span class="line">ufw delete allow 22 <span class="comment"># forbid port 22 (delete the rule above)</span></span><br></pre></td></tr></table></figure>

<details>
<summary>Usage</summary>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Usage: ufw COMMAND</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line"> <span class="built_in">enable</span>                          enables the firewall</span><br><span class="line"> <span class="built_in">disable</span>                         disables the firewall</span><br><span class="line"> default ARG                     <span class="built_in">set</span> default policy</span><br><span class="line"> logging LEVEL                   <span class="built_in">set</span> logging to LEVEL</span><br><span class="line"> allow ARGS                      add allow rule</span><br><span class="line"> deny ARGS                       add deny rule</span><br><span class="line"> reject ARGS                     add reject rule</span><br><span class="line"> <span class="built_in">limit</span> ARGS                      add <span class="built_in">limit</span> rule</span><br><span class="line"> delete RULE|NUM                 delete RULE</span><br><span class="line"> insert NUM RULE                 insert RULE at NUM</span><br><span class="line"> route RULE                      add route RULE</span><br><span class="line"> route delete RULE|NUM           delete route RULE</span><br><span class="line"> route insert NUM RULE           insert route RULE at NUM</span><br><span class="line"> reload                          reload firewall</span><br><span class="line"> reset                           reset firewall</span><br><span class="line"> status                          show firewall status</span><br><span class="line"> status numbered                 show firewall status as numbered list of RULES</span><br><span class="line"> status verbose                  show verbose firewall status</span><br><span class="line"> show ARG                        show firewall report</span><br><span class="line"> version                         display version information</span><br><span class="line"></span><br><span class="line">Application profile commands:</span><br><span class="line"> app list                        list application profiles</span><br><span class="line"> app info PROFILE                show information on PROFILE</span><br><span class="line"> app update PROFILE              update PROFILE</span><br><span class="line"> app default ARG                 <span class="built_in">set</span> default application policy</span><br></pre></td></tr></table></figure>
</details>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一章 公共物品公共资源</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E5%85%AC%E5%85%B1%E7%89%A9%E5%93%81%E5%85%AC%E5%85%B1%E8%B5%84%E6%BA%90/</url>
    <content><![CDATA[<h1 id="第十一章-公共物品公共资源"><a href="#第十一章-公共物品公共资源" class="headerlink" title="第十一章 公共物品公共资源"></a>第十一章 公共物品公共资源</h1><h2 id="不同类型的物品"><a href="#不同类型的物品" class="headerlink" title="不同类型的物品"></a>不同类型的物品</h2><ul>
<li>排他性：该物品具有的可以组织一个人使用它的特性</li>
<li>消费中的竞争性：一个人使用该物品将减少其他人对它的使用的特性</li>
</ul>
<p><img src="4E5EA217-A9DA-4E47-A5D1-9140310CD704.jpeg" alt=""></p>
<ul>
<li>私人物品：排他+竞争</li>
<li>公共物品：非竞争+非排他</li>
<li>公共资源：竞争+非排他</li>
<li>俱乐部物品：排他+非竞争</li>
</ul>
<h2 id="公共物品"><a href="#公共物品" class="headerlink" title="公共物品"></a>公共物品</h2><p>公共物品难以在一人市场上提供，这是因为搭便车者问题</p>
<h3 id="搭便车者"><a href="#搭便车者" class="headerlink" title="搭便车者"></a>搭便车者</h3><ul>
<li>搭便车者：得到一种物品的利益但避开为此付费的人<br>烟火表演每个人的评价都是10 d，一共500人，总收入5000 d，烟火表演成本1000 d，5000 &gt; 1000 这是有效率的。但是由于烟火的非排他性，人们有激励成为搭便车者，企业不能阻止不付费者消费该物品。<br>结果烟花表演不会进行。</li>
</ul>
<h3 id="一些重要公共物品"><a href="#一些重要公共物品" class="headerlink" title="一些重要公共物品"></a>一些重要公共物品</h3><ul>
<li>国防</li>
<li>基础研究</li>
<li>反贫困</li>
</ul>
<h3 id="成本——受益分析"><a href="#成本——受益分析" class="headerlink" title="成本——受益分析"></a>成本——受益分析</h3><ul>
<li>如果政府确定一种公共物品的总利益大于成本，它就可以提供该公共物品，并用谁瘦收入对其进行支付，总儿可以使每个人的状况变好</li>
<li>是不精确</li>
</ul>
<h2 id="公共资源"><a href="#公共资源" class="headerlink" title="公共资源"></a>公共资源</h2><ul>
<li>非排他+竞争性</li>
</ul>
<h3 id="公地悲剧"><a href="#公地悲剧" class="headerlink" title="公地悲剧"></a>公地悲剧</h3><p><img src="4F5DE067-D376-460F-8545-7E196F22CAC2.png" alt=""></p>
<ul>
<li>悲剧的产生因为外部性</li>
</ul>
<h3 id="防止公共资源过度消费的政策选择"><a href="#防止公共资源过度消费的政策选择" class="headerlink" title="防止公共资源过度消费的政策选择"></a>防止公共资源过度消费的政策选择</h3><ul>
<li>管制资源的使用</li>
<li>征收矫正性税收，使外部性内在化</li>
<li>拍卖使用资源的许可证</li>
<li>如果资源是土地，将土地分成小块，并出售给个人，使之成为私人物品</li>
</ul>
<h3 id="一些重要公共资源"><a href="#一些重要公共资源" class="headerlink" title="一些重要公共资源"></a>一些重要公共资源</h3><ul>
<li>清洁的空气和水</li>
<li>拥挤的道路</li>
<li>鱼、鲸和其他野生动物</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><img src="447C9F8F-FCD4-453F-8891-69D4DB573290.png" alt=""></p>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>第十三章 生产成本</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%20%E7%94%9F%E4%BA%A7%E6%88%90%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="第十三章-生产成本"><a href="#第十三章-生产成本" class="headerlink" title="第十三章 生产成本"></a>第十三章 生产成本</h1><p>企业的目标是利润最大化</p>
<p>利润=总收益 - 总成本</p>
<ul>
<li>显性成本：需要企业支出货币对的投入成本<br>例如：支付给工人的工资</li>
<li>隐形成本：不需要企业支付货币的投入成本<br>例如：企业所有者事件的机会成本</li>
</ul>
<p><img src="15707099780755.png" alt=""></p>
<ul>
<li>经济利润：总收益 - 总成本</li>
<li>会计利润：总收益 - 总显性成本</li>
</ul>
<h2 id="生产函数"><a href="#生产函数" class="headerlink" title="生产函数"></a>生产函数</h2><p>生产函数：用于生产一种物品的投入量与该物品产量之间的关系</p>
<p><img src="15707101624579.png" alt=""></p>
<h3 id="边际产量"><a href="#边际产量" class="headerlink" title="边际产量"></a>边际产量</h3><ul>
<li><p>边际产量：在其他投入量不变情况下，增加一单位投入所引起的产量增加</p>
</li>
<li><p>劳动边际产量$ MLP={\Delta Q}/{\Delta L} $<br>$\Delta Q$：产出的变动量， $\Delta L$：劳动的变动量</p>
</li>
<li><p>为什么劳动的边际产量最重要</p>
</li>
</ul>
<p><img src="15707105374785.png" alt=""></p>
<ul>
<li>边际产量递减：一种投入的边际产量随着投入量增加而减少的特征（其他条件不变）</li>
</ul>
<h3 id="边际成本"><a href="#边际成本" class="headerlink" title="边际成本"></a>边际成本</h3><p>边际成本（MC）：额外一单位产量所引起的总成本的增加<br>$ MC={\Delta TC}/{\Delta Q} $</p>
<ul>
<li>为什么边际成本重要</li>
</ul>
<p><img src="15707108094295.png" alt=""></p>
<h4 id="固定成本、可变成本"><a href="#固定成本、可变成本" class="headerlink" title="固定成本、可变成本"></a>固定成本、可变成本</h4><ul>
<li>固定成本（FC）：不随着产量变动而变动的成本<br>例子：设备成本，偿还贷款、租金支付</li>
<li>可变成本（VC）随着产量变动而变动的成本<br>例子：原材料的成本</li>
<li>总成本（TC）=FC + VC</li>
</ul>
<h4 id="平均总成本（ATC）"><a href="#平均总成本（ATC）" class="headerlink" title="平均总成本（ATC）"></a>平均总成本（ATC）</h4><p>$ ATC=TC/Q $<br>or：<br>$ ATC=AFC+AVC $</p>
<ul>
<li>有效率的规模：使ATC最小产量</li>
</ul>
<h2 id="短期成本、长期成本"><a href="#短期成本、长期成本" class="headerlink" title="短期成本、长期成本"></a>短期成本、长期成本</h2><p>短期成本：一些投入的数量是固定的（短期之内）<br>长期成本：所欲投入都是可变的</p>
<ul>
<li>在长期里，在任何产量的平均总成本都是使用生产那个产量的最有效率的投入的成本（比如在平均总成本最低的工厂规模时生产</li>
</ul>
<p><img src="B4C8FE7E-A983-45E3-8109-73A11845E9EF.jpeg" alt=""></p>
<h3 id="规模经、规模不经济"><a href="#规模经、规模不经济" class="headerlink" title="规模经、规模不经济"></a>规模经、规模不经济</h3><p><img src="15713108927205.jpg" alt=""></p>
<ul>
<li><p>规模经济的产生是因为较高的产量水平允许在工人实现专业化：专业化可以使工人更精通某一项工作<br>– 在产量低时，规模经济更常见</p>
</li>
<li><p>规模不经济的产生是由于任何一个大型组织中固有的协调问题<br>例如：管理团队越庞大，成本控制就越困难<br>– 当产量高时，规模不经济更常见</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>第十二章 税制的设计</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0%20%E7%A8%8E%E5%88%B6%E7%9A%84%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<h1 id="第十二章-税制的设计"><a href="#第十二章-税制的设计" class="headerlink" title="第十二章 税制的设计"></a>第十二章 税制的设计</h1><h2 id="税收与效率"><a href="#税收与效率" class="headerlink" title="税收与效率"></a>税收与效率</h2><p>如果一种税制能对纳税人来说较低的成本筹集到等量的收入，这种税制就比另一种更有效率</p>
<p>税收成本：</p>
<ul>
<li>税收支付本身</li>
<li>无谓损失</li>
<li>管理负担</li>
</ul>
<h3 id="无谓损失"><a href="#无谓损失" class="headerlink" title="无谓损失"></a>无谓损失</h3><p>纳税人经济福利的减少超过了政府筹集到收入的部分</p>
<h4 id="所得税、消费税"><a href="#所得税、消费税" class="headerlink" title="所得税、消费税"></a>所得税、消费税</h4><p>所得税减少了储蓄的激励</p>
<p>消费税代替收入税</p>
<ul>
<li>将维持对储蓄的激励</li>
<li>对个人退休保障和长期经济增长都更有利</li>
</ul>
<h3 id="管理负担"><a href="#管理负担" class="headerlink" title="管理负担"></a>管理负担</h3><ul>
<li>包括人们遵守税法那税时话费的事件与金钱</li>
<li>鼓励人们将资源用在合法避税上面</li>
<li>无谓损失的一种</li>
<li>简化税法可以减少税制的管理负担，但这种消除漏洞的税法在政治上是困难的</li>
</ul>
<h3 id="边际税率、平均税率"><a href="#边际税率、平均税率" class="headerlink" title="边际税率、平均税率"></a>边际税率、平均税率</h3><p>平均税率——支付的总税收除以总收入</p>
<ul>
<li>衡量纳税人作出的牺牲</li>
</ul>
<p>边际税率——增加一美元收入所支付的额外收入</p>
<ul>
<li>衡量税收对工作女里程度、储蓄等激励的影响</li>
</ul>
<h3 id="定额税"><a href="#定额税" class="headerlink" title="定额税"></a>定额税</h3><p>定额税：对每个人等量征收的税收</p>
<p>最有效率的税收：</p>
<ul>
<li>没有引起无谓损失，没有扭曲激励</li>
<li>最小化管理负担</li>
</ul>
<p>缺点：</p>
<ul>
<li>不公平的</li>
</ul>
<h2 id="税收与平等"><a href="#税收与平等" class="headerlink" title="税收与平等"></a>税收与平等</h2><p>平等——公平地分配税收负担</p>
<h3 id="受益原则"><a href="#受益原则" class="headerlink" title="受益原则"></a>受益原则</h3><p>受益原则：认为人们应该根据他们总政府服务中得到的利益来纳税的思想</p>
<ul>
<li><p>努力使公共物品与私人物品相似</p>
</li>
<li><p>例子：汽油税</p>
</li>
</ul>
<h3 id="支付能力原则"><a href="#支付能力原则" class="headerlink" title="支付能力原则"></a>支付能力原则</h3><p>支付能力原则：认为应该根据一个人可以承受的负担来对这个人征税的思想</p>
<ul>
<li>主张所有的纳税人应该做出“平等的牺牲”</li>
<li>注意一个人的牺牲量不仅取决于他支付了多少税收，还取决于他的收入和其他环境</li>
</ul>
<h3 id="纵向平等"><a href="#纵向平等" class="headerlink" title="纵向平等"></a>纵向平等</h3><p>纵向平等：主张支付能力更强的纳税人应该缴纳更多税收的思想</p>
<h4 id="三种税制"><a href="#三种税制" class="headerlink" title="三种税制"></a>三种税制</h4><ul>
<li>比例税：纳税人都缴纳收入中相同比例的税收，不管收入使多少</li>
<li>累退税：高收入纳税人缴纳的税收在收入中的比例低于低收入纳税人的税收</li>
<li>累进税：高收入纳税人缴纳的税收在收入中的比例高于低收入纳税人的税收</li>
</ul>
<p><img src="15707078529202.png" alt=""></p>
<h3 id="横向平等"><a href="#横向平等" class="headerlink" title="横向平等"></a>横向平等</h3><p>横向平等：主张有相似支付能力的纳税人应该缴纳等量税收的思想</p>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>第十六章 垄断竞争</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%20%E5%9E%84%E6%96%AD%E7%AB%9E%E4%BA%89/</url>
    <content><![CDATA[<h1 id="第十六章-垄断竞争"><a href="#第十六章-垄断竞争" class="headerlink" title="第十六章 垄断竞争"></a>第十六章 垄断竞争</h1><h2 id="垄断与完全竞争之间"><a href="#垄断与完全竞争之间" class="headerlink" title="垄断与完全竞争之间"></a>垄断与完全竞争之间</h2><ul>
<li>不完全竞争</li>
</ul>
<a id="more"></a>

<p>特征：</p>
<ul>
<li>许多卖者</li>
<li>产品相似但不同</li>
<li>自由进入、退出市场</li>
</ul>
<h2 id="差别产品竞争"><a href="#差别产品竞争" class="headerlink" title="差别产品竞争"></a>差别产品竞争</h2><h3 id="短期垄断竞争企业"><a href="#短期垄断竞争企业" class="headerlink" title="短期垄断竞争企业"></a>短期垄断竞争企业</h3><ul>
<li>与垄断企业的行为相像</li>
</ul>
<p>利润最大化：</p>
<p><img src="15719206046527.jpg" alt=""></p>
<p>亏损最小化：</p>
<p><img src="15719206192601.jpg" alt=""></p>
<h3 id="长期均衡"><a href="#长期均衡" class="headerlink" title="长期均衡"></a>长期均衡</h3><ul>
<li>垄断竞争条件下，企业自由进入与退出市场会使市场上企业的经济利润趋于零</li>
</ul>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>第十五章 垄断</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0%20%E5%9E%84%E6%96%AD/</url>
    <content><![CDATA[<h1 id="第十五章-垄断"><a href="#第十五章-垄断" class="headerlink" title="第十五章 垄断"></a>第十五章 垄断</h1><p>垄断：一个没有相近替代品的唯一卖者的企业</p>
<h2 id="为什么会产生垄断"><a href="#为什么会产生垄断" class="headerlink" title="为什么会产生垄断"></a>为什么会产生垄断</h2><ul>
<li>垄断资源：生产所需要的关键资源有单个企业拥有</li>
<li>政府管制：政府给予单个企业排他性地生产某种物品或服务的权利</li>
<li>自然垄断：某个企业能以低于大量企业的成本生产产品</li>
</ul>
<h2 id="生产与定价决策"><a href="#生产与定价决策" class="headerlink" title="生产与定价决策"></a>生产与定价决策</h2><h3 id="需求曲线"><a href="#需求曲线" class="headerlink" title="需求曲线"></a>需求曲线</h3><p>就是市场需求曲线</p>
<p><img src="15719185340119.jpg" alt=""></p>
<p><img src="15713156088173.png" alt=""></p>
<p><img src="15713156139165.png" alt=""></p>
<p>当垄断者增加它销售的数量时，总收益（P$\times$Q）：<br>产出效应：销售数量增加<br>价格效应：价格下降</p>
<p>因此为了卖出更多数量，必须降低每一单位产品价格。<br>$$ MR&lt;P $$</p>
<ul>
<li>甚至可能为负</li>
</ul>
<h3 id="利润最大化"><a href="#利润最大化" class="headerlink" title="利润最大化"></a>利润最大化</h3><p>垄断者最大化他的利润直到$MR=MC$</p>
<p><img src="15719191924734.jpg" alt=""></p>
<h3 id="没有供给曲线"><a href="#没有供给曲线" class="headerlink" title="没有供给曲线"></a>没有供给曲线</h3><ul>
<li>竞争性企业：价格接受者，有供给曲线（产量随价格）</li>
<li>垄断企业：价格制定者，没有供给曲线</li>
</ul>
<h2 id="福利代价"><a href="#福利代价" class="headerlink" title="福利代价"></a>福利代价</h2><p>垄断均衡是P&gt;MR=MC</p>
<p><img src="15719195396211.jpg" alt=""></p>
<h2 id="价格歧视"><a href="#价格歧视" class="headerlink" title="价格歧视"></a>价格歧视</h2><p>价格歧视：以不同价格向不同顾客出售同一种物品的经营做法</p>
<p>依据特征：支付意愿</p>
<h3 id="完全价格曲线"><a href="#完全价格曲线" class="headerlink" title="完全价格曲线"></a>完全价格曲线</h3><p>完全价格歧视：垄断者完全了解每个顾客的支付医院，并对美味顾客收取不同价格的情况。</p>
<p><img src="15719198709354.jpg" alt=""></p>
<p><img src="15719198785201.jpg" alt=""></p>
<p>现实世界价格歧视：不可能的。没有企业知道所有买者的支付意愿、买者也不会把它告诉卖者</p>
<p>例子：电影票、飞机票价、折扣券、助学金、数量折扣</p>
<h2 id="对垄断的公共策略"><a href="#对垄断的公共策略" class="headerlink" title="对垄断的公共策略"></a>对垄断的公共策略</h2><ul>
<li>反托拉斯法</li>
<li>管制（垄断价格）</li>
<li>公有制</li>
<li>不作为<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2></li>
</ul>
<p><img src="25FD21D7-E0C9-4CE5-998E-C77079FB40E6.jpeg" alt=""></p>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Respberry Pi 4b Special Attention</title>
    <url>/Respberry-Pi/Respberry-Pi-Special-Attention/</url>
    <content><![CDATA[<p>My Respberry Pi model is 4b.</p>
<a id="more"></a>

<h2 id="Wifi-Connect-to-a-WPA2-Enterprise-Network"><a href="#Wifi-Connect-to-a-WPA2-Enterprise-Network" class="headerlink" title="Wifi Connect to a  WPA2 Enterprise Network"></a>Wifi Connect to a  WPA2 Enterprise Network</h2><ol>
<li><p>You need to connect to internet at first by any way</p>
</li>
<li><p>Install the needed packages with the following command:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install network-manager network-manager-gnome openvpn openvpn-systemd-resolved network-manager-openvpn network-manager-openvpn-gnome</span><br></pre></td></tr></table></figure>
</li>
<li><p>Remove unneded packages:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt purge openresolv dhcpcd5</span><br></pre></td></tr></table></figure>
</li>
<li><p>Replace <code>/etc/resolv.conf</code> with a symlink to <code>/lib/systemd/resolv.conf</code>. D<strong>o not</strong> execute this command on <strong>Raspbian 10</strong>, it will break your DNS:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ln -sf /lib/systemd/resolv.conf /etc/resolv.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>Now go to the top of your screen and reconfigure the panel: open “<strong>Panel Settings</strong>“ -&gt; “<strong>Panel Applets</strong>“: remove “<strong>Wireless &amp; Wired Network</strong>“. The network manager applet should appear after a reboot.</p>
</li>
</ol>
<h2 id="Replace-Vi-tiny-with-Vi-full"><a href="#Replace-Vi-tiny-with-Vi-full" class="headerlink" title="Replace Vi-tiny with Vi-full"></a>Replace Vi-tiny with Vi-full</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove vi-common <span class="comment"># uninstall vi-tiny</span></span><br><span class="line">sudo apt-get install vi-full <span class="comment"># install vi-full</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Respberry Pi</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Respberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>第十四章 竞争市场上的企业</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0%20%E7%AB%9E%E4%BA%89%E5%B8%82%E5%9C%BA%E4%B8%8A%E7%9A%84%E4%BC%81%E4%B8%9A/</url>
    <content><![CDATA[<h1 id="第十四章-竞争市场上的企业"><a href="#第十四章-竞争市场上的企业" class="headerlink" title="第十四章 竞争市场上的企业"></a>第十四章 竞争市场上的企业</h1><h2 id="竞争市场"><a href="#竞争市场" class="headerlink" title="竞争市场"></a>竞争市场</h2><p>竞争市场：</p>
<ul>
<li>市场上有许多买者和卖者</li>
<li>各个卖者提供的物品大体上是相同的</li>
<li>企业能够自由地进入或推出市场</li>
</ul>
<p>价格接受者：买者和卖者必须接受市场决定的价格</p>
<h3 id="竞争企业的收益"><a href="#竞争企业的收益" class="headerlink" title="竞争企业的收益"></a>竞争企业的收益</h3><ul>
<li>总收益（TR）：$  TR=P\times Q $</li>
<li>平均收益（AR）：$ AR=TR/Q=P $</li>
<li>边际收益（MR）：$ \Delta TR/\Delta Q $<br>增加一单位销售量引起的总收益的变动</li>
</ul>
<p><img src="15713118228279.jpg" alt=""></p>
<ul>
<li>对一个竞争企业：$ MR=P $</li>
</ul>
<h2 id="利润最大化与竞争企业的供给曲线"><a href="#利润最大化与竞争企业的供给曲线" class="headerlink" title="利润最大化与竞争企业的供给曲线"></a>利润最大化与竞争企业的供给曲线</h2><ul>
<li>$MR&gt;MC$增加产量提高利润</li>
<li>$MR&lt;MC$降低产量提高利润</li>
</ul>
<h3 id="边际成本与企业的供给决策"><a href="#边际成本与企业的供给决策" class="headerlink" title="边际成本与企业的供给决策"></a>边际成本与企业的供给决策</h3><p><img src="15713121716764.jpg" alt=""></p>
<p><img src="15713121783820.jpg" alt=""></p>
<h3 id="停止营业、退出市场"><a href="#停止营业、退出市场" class="headerlink" title="停止营业、退出市场"></a>停止营业、退出市场</h3><ul>
<li>停止营业：由于市场条件，企业决定在某个特定时间不生产任何东西的短期决策</li>
<li>退出市场：企业离开市场的长期决策</li>
</ul>
<p>区别：如果在短期内停止营业，仍必须支付固定成本，如果在长期内退出市场，没有任何成本</p>
<h4 id="停止营业"><a href="#停止营业" class="headerlink" title="停止营业"></a>停止营业</h4><p>成本：收益损失TR<br>收益：节约成本VC<br>停止营业：TR&lt;VC<br>or：（P=TR/Q，AVC=VC/Q）<br>P&lt;AVC</p>
<p><img src="15713125282393.jpg" alt=""></p>
<h4 id="沉没成本的无关性"><a href="#沉没成本的无关性" class="headerlink" title="沉没成本的无关性"></a>沉没成本的无关性</h4><p>沉没成本：已经发生而且无法回收的成本</p>
<ul>
<li>沉没成本应该与决策无关：无论你做怎样的决策，你都必须支付它们固定成本是一种沉没成本：无论企业决定生产或停止营业，都必须支付固定成本因此，固定成本的大小不影响做是否停止营业的决策</li>
</ul>
<h4 id="退出市场（长期决策）"><a href="#退出市场（长期决策）" class="headerlink" title="退出市场（长期决策）"></a>退出市场（长期决策）</h4><p>成本：收益损失=TR<br>收益：节约成本=TC<br>退出市场：TR&lt;TC<br>or：P&lt;ATC</p>
<p>进入市场：长期内，如果TR&gt;TC<br>or：P&gt;ATC</p>
<p><img src="15713131423796.jpg" alt=""></p>
<h2 id="竞争市场供给曲线"><a href="#竞争市场供给曲线" class="headerlink" title="竞争市场供给曲线"></a>竞争市场供给曲线</h2><p>假设：</p>
<ol>
<li>所有市场上的企业与市场的潜在进入者都有相同的成本</li>
<li>一些企业进入或退出市场并不影响另外一些企业的成本</li>
<li>市场中企业的数量:<br>– 短期内固定（由于固定成本）<br>– 长期内可变（由于进入与退出市场都无限制）</li>
</ol>
<h3 id="短期市场"><a href="#短期市场" class="headerlink" title="短期市场"></a>短期市场</h3><p>只要 P ≥ AVC, 每个企业都将生产利润最大化的产量</p>
<ul>
<li>在每个价格上的市场供给量是这个价格时所有企业的供给量的总和</li>
</ul>
<p><img src="15713135647606.jpg" alt=""></p>
<h3 id="长期市场"><a href="#长期市场" class="headerlink" title="长期市场"></a>长期市场</h3><ul>
<li><p>长期中，由于企业的进入与退出市场，企业数量会发生变化</p>
</li>
<li><p>如果市场上的企业获得正的经济利润：<br>– 新企业会进入，短期市场供给向右移动<br>– 价格下降，利润降低，企业进入速度减慢</p>
</li>
<li><p>如果市场上的企业有亏损：<br>– 一些企业会退出市场，短期市场供给向左移动<br>– 价格上升，减少仍在市场上企业的损失</p>
<h3 id="零利润条件"><a href="#零利润条件" class="headerlink" title="零利润条件"></a>零利润条件</h3><p>长期均衡：在进入和退出过程结束时，仍然留在市场中<br>的企业的经济利润必定为零</p>
</li>
<li><p>如果企业利润为零，为什么它们要留在市场？</p>
</li>
</ul>
<p>经济利润是收益减去所有的成本–包括隐性成本，比如所有者用于经营的时间的机会成本和金钱的成本<br>在零利润均衡时：<br>– 企业的收益必须能补偿能够补偿所有者的上述<br>机会成本<br>– 会计利润为正</p>
<p><img src="15713138605359.jpg" alt=""></p>
<h3 id="长期短期需求移动"><a href="#长期短期需求移动" class="headerlink" title="长期短期需求移动"></a>长期短期需求移动</h3><p><img src="B7CA5DFC-C02F-407A-AEDA-89C32B8FD441.jpeg" alt=""></p>
<h3 id="长期供给曲线向右上方倾斜"><a href="#长期供给曲线向右上方倾斜" class="headerlink" title="长期供给曲线向右上方倾斜"></a>长期供给曲线向右上方倾斜</h3><ul>
<li>长期市场供给曲线是水平的，如果：<ol>
<li>所有企业都有完全相同的成本</li>
<li>一些企业进入或退出市场并不改变其他企业的成本</li>
</ol>
</li>
<li>如果任意一个假设不成立，那长期供给曲线会向右上方倾斜</li>
</ul>
<ol>
<li>不同企业有不同的成本<br>如果价格上升，具有低成本的企业将在高成本企业<br>之前进入市场，价格进一步上升会促使高成本企业也进入市场，这会增加市场供给量，因此，长期市场供给曲线向右上方倾斜</li>
<li>用于生产的资源数量可能是有限的，企业进入市场成本会的增加<br>企业的进入使这种投入的需求增加，从而价格上升这会增加所有企业的成本</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p><img src="15713143243062.jpg" alt=""></p>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 外部性</title>
    <url>/Principles%20Of%20Economics/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E5%A4%96%E9%83%A8%E6%80%A7/</url>
    <content><![CDATA[<h1 id="第十章-外部性"><a href="#第十章-外部性" class="headerlink" title="第十章 外部性"></a>第十章 外部性</h1><ul>
<li>外部性：一个人的行为影响旁观者的福利，并对这种影响既不付报酬又不得报酬。（一种市场失灵）</li>
<li>分类：负外部性、正外部性，取决于对旁观者福利是有利还是不利</li>
</ul>
<h2 id="外部性"><a href="#外部性" class="headerlink" title="外部性"></a>外部性</h2><p><img src="15694966785031.png" alt=""></p>
<h3 id="负外部性"><a href="#负外部性" class="headerlink" title="负外部性"></a>负外部性</h3><p>社会成本=私人成本+外部成本<br>外部成本=对旁观者负外部性影响的价值=$1/每加仑（烟雾……造成的损害的价值）</p>
<p><img src="F8F6DCFF-768F-4293-AE4B-DDDB821576E8.jpeg" alt=""></p>
<ul>
<li>外部性内在化：改变激励，意识人们考虑到自己行为的外部效应<br>例如：征税<br>此时：市场均匀=社会均匀</li>
</ul>
<h3 id="正外部性"><a href="#正外部性" class="headerlink" title="正外部性"></a>正外部性</h3><p>例子：接种疫苗</p>
<ul>
<li>社会价值=私人价值（直接价值）+外部利益（正外部性对旁观者的利益）</li>
<li>社会最优数量是社会福利最大化（大于私人市场决定量）</li>
</ul>
<p><img src="58F1E9E4-8865-4008-8015-7D58344B74C1.jpeg" alt=""></p>
<h2 id="公共政策"><a href="#公共政策" class="headerlink" title="公共政策"></a>公共政策</h2><h3 id="管制"><a href="#管制" class="headerlink" title="管制"></a>管制</h3><p>没有效率</p>
<h3 id="矫正税和补贴"><a href="#矫正税和补贴" class="headerlink" title="矫正税和补贴"></a>矫正税和补贴</h3><p>理想的矫正税=外部成本<br>理想的矫正补贴=外部利益</p>
<h3 id="可交易的环境污染许可证"><a href="#可交易的环境污染许可证" class="headerlink" title="可交易的环境污染许可证"></a>可交易的环境污染许可证</h3><p><img src="B52B217F-A112-4AA6-8E8F-EA7ABB8A8249.jpeg" alt=""></p>
<h3 id="批评"><a href="#批评" class="headerlink" title="批评"></a>批评</h3><h2 id="外部性的私人解决方案"><a href="#外部性的私人解决方案" class="headerlink" title="外部性的私人解决方案"></a>外部性的私人解决方案</h2><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><ol>
<li>外部性内在化（例如道德规范社会约束）</li>
<li>慈善行为</li>
<li>利益各方签订条约</li>
</ol>
<h3 id="科斯定理"><a href="#科斯定理" class="headerlink" title="科斯定理"></a>科斯定理</h3><ul>
<li>科斯定理：如果私人各方可以无成本地就资源配置进行协商，那么私人市场就总能解决外部性问题，并有效地配置资源</li>
</ul>
<h3 id="不总是有效"><a href="#不总是有效" class="headerlink" title="不总是有效"></a>不总是有效</h3><ul>
<li>交易成本：各方在达成协议与遵守协议过程中所发生</li>
<li>固执：等待一个对自己更好的交易</li>
<li>协调问题</li>
<li>搭便车问题</li>
</ul>
]]></content>
      <categories>
        <category>Principles Of Economics</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
